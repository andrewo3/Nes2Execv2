ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : /mnt/ntfs_e/projects/nes/utaco/src/nsfd_v26/driver.s
Current file: /mnt/ntfs_e/projects/nes/utaco/src/nsfd_v26/driver.s

000000r 1               ;
000000r 1               ; The NSF music driver for FamiTracker
000000r 1               ; Version 2.6
000000r 1               ; By jsr (zxy965r@tninet.se)
000000r 1               ; assemble with ca65
000000r 1               ;
000000r 1               ; Documentation is in readme.txt
000000r 1               ;
000000r 1               ; Tab stop is 4
000000r 1               ;
000000r 1               ;
000000r 1               ; ToDo;
000000r 1               ;  - Namco
000000r 1               ;  - Sunsoft
000000r 1               ;  - Support for multiple chips
000000r 1               ;
000000r 1               ;
000000r 1               ; Known bugs:
000000r 1               ;
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;
000000r 1               ; Assembler code switches
000000r 1               ;
000000r 1               
000000r 1               USE_BANKSWITCH = 0		; Enable bankswitching code
000000r 1               USE_DPCM = 1			; Enable DPCM channel (currently broken, leave enabled to avoid trouble).
000000r 1               						; Also leave enabled for expansion chips
000000r 1               
000000r 1               NTSC_PERIOD_TABLE = 1	; Enable this to include the NTSC period table
000000r 1               PAL_PERIOD_TABLE = 1	; Enable this to include the PAL period table
000000r 1               
000000r 1               ENABLE_ROW_SKIP = 1		; Enable this to add code for seeking to a row > 0 when using skip command
000000r 1               
000000r 1               ;USE_VRC6 = 1 			; Enable this to include VRC6 code
000000r 1               ;USE_MMC5 = 1			; Enable this to include MMC5 code
000000r 1               ;USE_VRC7 = 1			; Enable this to include VRC7 code
000000r 1               ;USE_FDS = 1			; Enable this to include FDS code
000000r 1               ;USE_N106 = 1			; Enable this to include N106 code
000000r 1               ;USE_5B = 1				; Enable this to include 5B code
000000r 1               
000000r 1               ;ENABLE_SFX = 1			; Enable this to enable sound effect support (not yet working)
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;
000000r 1               ; Constants
000000r 1               ;
000000r 1               TUNE_PATTERN_LENGTH		= $00
000000r 1               TUNE_FRAME_LIST_POINTER	= $01
000000r 1               
000000r 1               ; Setup the pattern number -> channel mapping, as exported by the tracker
000000r 1               
000000r 1               .if .defined(USE_VRC6)			; 2A03 + VRC6 channels
000000r 1               	CHANNELS		= 8
000000r 1               	DPCM_CHANNEL	= 7
000000r 1               	VRC6_CHANNELS	= 4						; Start of VRC channels
000000r 1               	SAW_CHANNEL		= VRC6_CHANNELS + 2		; Saw channel
000000r 1               	WAVE_CHANS 		= CHANNELS - 1
000000r 1               .elseif .defined(USE_VRC7)		; 2A03 + VRC7 channels
000000r 1               	CHANNELS		= 11
000000r 1               	DPCM_CHANNEL	= 10
000000r 1               	WAVE_CHANS 		= 4
000000r 1               	VRC7_CHANNEL	= 4
000000r 1               .elseif .defined(USE_MMC5)		; 2A03 + MMC5 channels
000000r 1               	CHANNELS		= 7
000000r 1               	DPCM_CHANNEL	= 6
000000r 1               	WAVE_CHANS 		= CHANNELS - 1
000000r 1               .elseif .defined(USE_FDS)		; 2A03 + FDS
000000r 1               	CHANNELS		= 6
000000r 1               	DPCM_CHANNEL	= 5
000000r 1               	FDS_CHANNEL		= 4
000000r 1               	WAVE_CHANS		= CHANNELS - 1
000000r 1               .else							; 2A03 channels
000000r 1               	.ifdef USE_DPCM
000000r 1               		CHANNELS	 = 5
000000r 1               		DPCM_CHANNEL = 4
000000r 1               		WAVE_CHANS 	 = CHANNELS - 1
000000r 1               	.else
000000r 1               		CHANNELS	 = 4
000000r 1               		WAVE_CHANS 	 = CHANNELS
000000r 1               	.endif
000000r 1               .endif
000000r 1               
000000r 1               EFF_CHANS = CHANNELS - 1		; # of channels using vibrato & arpeggio effects (not used by DPCM)
000000r 1               
000000r 1               ; Number of wave channels
000000r 1               ;.ifdef USE_DPCM
000000r 1               ;	WAVE_CHANS = CHANNELS - 1
000000r 1               ;.else
000000r 1               ;	WAVE_CHANS = CHANNELS
000000r 1               ;.endif
000000r 1               
000000r 1               ; Noise channel
000000r 1               NOISE_CHANNEL = 3
000000r 1               
000000r 1               ;.if .defined(ENABLE_SFX)
000000r 1               ;	SFX_CHANS		= CHANNELS * 2
000000r 1               ;	SFX_WAVE_CHANS 	= WAVE_CHANS * 2
000000r 1               ;.else
000000r 1               	SFX_CHANS		= CHANNELS
000000r 1               	SFX_WAVE_CHANS 	= WAVE_CHANS
000000r 1               ;.endif
000000r 1               
000000r 1               ; Header item offsets
000000r 1               HEAD_SPEED				= 11
000000r 1               HEAD_TEMPO				= 12
000000r 1               
000000r 1               ;SPEED_DIV_NTSC			= 60 * 60;
000000r 1               ;SPEED_DIV_PAL			= 60 * 50;
000000r 1               
000000r 1               EFF_NONE				= 0
000000r 1               EFF_ARPEGGIO			= 1
000000r 1               EFF_PORTAMENTO			= 2
000000r 1               EFF_PORTA_UP			= 3
000000r 1               EFF_PORTA_DOWN			= 4
000000r 1               EFF_SLIDE_UP_LOAD		= 5
000000r 1               EFF_SLIDE_UP			= 6
000000r 1               EFF_SLIDE_DOWN_LOAD		= 7
000000r 1               EFF_SLIDE_DOWN			= 8
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               
000000r 1               ;
000000r 1               ; Variables that must be on zero-page
000000r 1               ;
000000r 1  xx           var_Temp:				.res 1						; Temporary 8-bit
000001r 1  xx           var_Temp2:				.res 1
000002r 1  xx           var_Temp3:				.res 1
000003r 1  xx           var_Temp4:				.res 1
000004r 1  xx xx        var_Temp16:				.res 2						; Temporary 16-bit
000006r 1  xx xx        var_Temp_Pointer:		.res 2						; Temporary
000008r 1  xx xx        var_Temp_Pointer2:		.res 2
00000Ar 1  xx xx        var_Temp_Pattern:		.res 2						; Pattern address (temporary)
00000Cr 1  xx xx        var_Note_Table:			.res 2
00000Er 1  xx           var_Temp_Inst:			.res 1
00000Fr 1               
00000Fr 1  xx xx        ACC:					.res 2						; Used by division routine
000011r 1  xx xx        AUX:					.res 2
000013r 1  xx xx        EXT:					.res 2
000015r 1               
000015r 1               .ifdef USE_FDS
000015r 1               var_Wave_pointer:		.res 2
000015r 1               .endif
000015r 1               .ifdef USE_VRC7
000015r 1               var_Period:				.res 2
000015r 1               .endif
000015r 1               
000015r 1  xx           last_zp_var:			.res 1						; Not used
000016r 1               
000016r 1               
000016r 1               .segment "BSS"
000000r 1               
000000r 1               ;
000000r 1               ; Driver variables
000000r 1               ;
000000r 1               
000000r 1               ; Song header (necessary to be in order)
000000r 1  xx xx        var_Song_list:			.res 2						; Song list address
000002r 1  xx xx        var_Instrument_list:	.res 2						; Instrument list address
000004r 1               .ifdef USE_DPCM
000004r 1  xx xx        var_dpcm_inst_list:		.res 2						; DPCM instruments
000006r 1  xx xx        var_dpcm_pointers:		.res 2						; DPCM sample pointers
000008r 1               .endif
000008r 1  xx           var_SongFlags:			.res 1						; Song flags, bit 0 = bankswitched, bit 1 = old vibrato, bit 2 - 7 = unused
000009r 1               .ifdef USE_FDS
000009r 1               var_Wavetables:			.res 2						; FDS waves
000009r 1               .endif
000009r 1               
000009r 1  xx           var_Channels:			.res 1						; Channel enable/disable
00000Ar 1               
00000Ar 1               ; Track header (necessary to be in order)
00000Ar 1  xx xx        var_Frame_List:			.res 2						; Pattern list address
00000Cr 1  xx           var_Frame_Count:		.res 1						; Number of frames
00000Dr 1  xx           var_Pattern_Length:		.res 1						; Global pattern length
00000Er 1  xx           var_Speed:				.res 1						; Speed setting
00000Fr 1  xx           var_Tempo:				.res 1						; Tempo setting
000010r 1  xx           var_InitialBank:		.res 1
000011r 1               
000011r 1               ; General
000011r 1  xx           var_PlayerFlags:		.res 1						; Player flags, bit 0 = playing, bit 1 - 7 unused
000012r 1  xx           var_Pattern_Pos:		.res 1						; Global pattern row
000013r 1  xx           var_Current_Frame:		.res 1						; Current frame
000014r 1  xx           var_Load_Frame:			.res 1						; 1 if new frame should be loaded
000015r 1               
000015r 1  xx xx        var_Tempo_Accum:		.res 2						; Variables for speed division
000017r 1  xx xx        var_Tempo_Count:		.res 2						;  (if tempo support is not needed then this can be optimized)
000019r 1  xx xx        var_Tempo_Dec:			.res 2
00001Br 1  xx           var_VolTemp:			.res 1						; So the Exx command will work
00001Cr 1  xx           var_Sweep:				.res 1						; This has to be saved
00001Dr 1               
00001Dr 1               .ifdef USE_BANKSWITCH
00001Dr 1  xx           var_Bank:				.res 1
00001Er 1               .endif
00001Er 1  xx           var_Jump:				.res 1						; If a Jump should be executed
00001Fr 1  xx           var_Skip:				.res 1						; If a Skip should be executed
000020r 1               .ifdef ENABLE_ROW_SKIP
000020r 1  xx           var_SkipTo:				.res 1						; Skip to row number
000021r 1               .endif
000021r 1               
000021r 1  xx           var_sequence_ptr:		.res 1
000022r 1  xx           var_sequence_result:	.res 1
000023r 1               
000023r 1               ;var_enabled_channels:	.res 1
000023r 1               
000023r 1               ; Channel variables
000023r 1               
000023r 1               ; General channel variables, used by the pattern reader (all channels)
000023r 1  xx xx xx xx  var_ch_PatternAddrLo:	.res CHANNELS				; Holds current pattern position
000027r 1  xx           
000028r 1  xx xx xx xx  var_ch_PatternAddrHi:	.res CHANNELS
00002Cr 1  xx           
00002Dr 1               .ifdef USE_BANKSWITCH
00002Dr 1  xx xx xx xx  var_ch_Bank:			.res CHANNELS				; Pattern bank
000031r 1  xx           
000032r 1               .endif
000032r 1  xx xx xx xx  var_ch_Note:			.res CHANNELS				; Current channel note
000036r 1  xx           
000037r 1  xx xx xx xx  var_ch_VolColumn:		.res CHANNELS				; Volume column
00003Br 1  xx           
00003Cr 1  xx xx xx xx  var_ch_Delay:			.res CHANNELS				; Delay command
000040r 1  xx           
000041r 1  xx xx xx xx  var_ch_NoteCut:			.res CHANNELS
000045r 1  xx           
000046r 1  xx xx xx xx  var_ch_State:			.res CHANNELS
00004Ar 1  xx           
00004Br 1  xx xx xx xx  var_ch_FinePitch:		.res CHANNELS				; Fine pitch setting
00004Fr 1  xx           
000050r 1               
000050r 1  xx xx xx xx  var_ch_NoteDelay:		.res CHANNELS				; Delay in rows until next note
000054r 1  xx           
000055r 1  xx xx xx xx  var_ch_DefaultDelay:	.res CHANNELS				; Default row delay, if exists
000059r 1  xx           
00005Ar 1               
00005Ar 1               ; Following is specific to chip channels (2A03, VRC6...)
00005Ar 1               
00005Ar 1  xx xx xx xx  var_ch_TimerPeriodHi:	.res EFF_CHANS				; Current channel note period
00005Er 1  xx xx xx xx  var_ch_TimerPeriodLo:	.res EFF_CHANS
000062r 1  xx xx xx xx  var_ch_PeriodCalcLo:	.res EFF_CHANS 				; Frequency after fine pitch and vibrato has been applied
000066r 1  xx xx xx xx  var_ch_PeriodCalcHi:	.res EFF_CHANS
00006Ar 1  xx xx xx xx  var_ch_OutVolume:		.res CHANNELS				; Volume for the APU
00006Er 1  xx           
00006Fr 1  xx xx xx xx  var_ch_VolSlide:		.res CHANNELS				; Volume slide
000073r 1  xx           
000074r 1               
000074r 1               ; --- Testing ---
000074r 1               ;var_ch_LoopCounter:		.res CHANNELS
000074r 1               ; --- Testing ---
000074r 1               
000074r 1               ; Square 1 & 2 variables
000074r 1  xx xx        var_ch_Sweep:			.res 2						; Hardware sweep
000076r 1  xx xx        var_ch_PrevFreqHigh:	.res 2						; Used only by 2A03 pulse channels
000078r 1               
000078r 1               ; Sequence variables
000078r 1  xx xx xx xx  var_ch_SeqVolume:		.res SFX_WAVE_CHANS * 2		; Sequence 1: Volume
00007Cr 1  xx xx xx xx  
000080r 1  xx xx xx xx  var_ch_SeqArpeggio:		.res SFX_WAVE_CHANS * 2		; Sequence 2: Arpeggio
000084r 1  xx xx xx xx  
000088r 1  xx xx xx xx  var_ch_SeqPitch:		.res SFX_WAVE_CHANS * 2		; Sequence 3: Pitch bend
00008Cr 1  xx xx xx xx  
000090r 1  xx xx xx xx  var_ch_SeqHiPitch:		.res SFX_WAVE_CHANS * 2		; Sequence 4: High speed pitch bend
000094r 1  xx xx xx xx  
000098r 1  xx xx xx xx  var_ch_SeqDutyCycle:	.res SFX_WAVE_CHANS * 2		; Sequence 5: Duty cycle / Noise Mode
00009Cr 1  xx xx xx xx  
0000A0r 1  xx xx xx xx  var_ch_Volume:			.res SFX_WAVE_CHANS			; Output volume
0000A4r 1  xx xx xx xx  var_ch_DutyCycle:		.res SFX_WAVE_CHANS			; Duty cycle / Noise mode
0000A8r 1  xx xx xx xx  var_ch_SequencePtr1:	.res SFX_WAVE_CHANS			; Index pointers for sequences
0000ACr 1  xx xx xx xx  var_ch_SequencePtr2:	.res SFX_WAVE_CHANS
0000B0r 1  xx xx xx xx  var_ch_SequencePtr3:	.res SFX_WAVE_CHANS
0000B4r 1  xx xx xx xx  var_ch_SequencePtr4:	.res SFX_WAVE_CHANS
0000B8r 1  xx xx xx xx  var_ch_SequencePtr5:	.res SFX_WAVE_CHANS
0000BCr 1               
0000BCr 1               ; Track variables for effects
0000BCr 1  xx xx xx xx  var_ch_Effect:			.res EFF_CHANS				; Arpeggio & portamento
0000C0r 1  xx xx xx xx  var_ch_EffParam:		.res EFF_CHANS				; Effect parameter (used by portamento and arpeggio)
0000C4r 1               
0000C4r 1  xx xx xx xx  var_ch_PortaToHi:		.res EFF_CHANS 				; Portamento
0000C8r 1  xx xx xx xx  var_ch_PortaToLo:		.res EFF_CHANS
0000CCr 1  xx xx xx xx  var_ch_ArpeggioCycle:	.res EFF_CHANS				; Arpeggio cycle
0000D0r 1               
0000D0r 1  xx xx xx xx  var_ch_VibratoPos:		.res EFF_CHANS				; Vibrato
0000D4r 1  xx xx xx xx  var_ch_VibratoDepth:	.res EFF_CHANS
0000D8r 1  xx xx xx xx  var_ch_VibratoSpeed:	.res EFF_CHANS
0000DCr 1  xx xx xx xx  var_ch_TremoloPos:		.res EFF_CHANS				; Tremolo
0000E0r 1  xx xx xx xx  var_ch_TremoloDepth:	.res EFF_CHANS				; combine these
0000E4r 1  xx xx xx xx  var_ch_TremoloSpeed:	.res EFF_CHANS
0000E8r 1               
0000E8r 1               ;var_ch_VibratoParam:	.res EFF_CHANS
0000E8r 1               ;var_ch_TremoloParam:	.res EFF_CHANS
0000E8r 1               
0000E8r 1               ; DPCM variables
0000E8r 1               .ifdef USE_DPCM
0000E8r 1  xx           var_ch_SamplePtr:		.res 1						; DPCM sample pointer
0000E9r 1  xx           var_ch_SampleLen:		.res 1						; DPCM sample length
0000EAr 1  xx           var_ch_SamplePitch:		.res 1						; DPCM sample pitch
0000EBr 1  xx           var_ch_DPCMDAC:			.res 1						; DPCM delta counter setting
0000ECr 1  xx           var_ch_DPCM_Offset:		.res 1
0000EDr 1  xx           var_ch_DPCM_Retrig:		.res 1						; DPCM retrigger
0000EEr 1  xx           var_ch_DPCM_RetrigCntr:	.res 1
0000EFr 1  xx           var_ch_DPCM_EffPitch:	.res 1
0000F0r 1               .endif
0000F0r 1               
0000F0r 1               .ifdef USE_MMC5
0000F0r 1               var_ch_PrevFreqHighMMC5: .res 2					; MMC5
0000F0r 1               .endif
0000F0r 1               
0000F0r 1               .ifdef USE_VRC7
0000F0r 1               var_ch_vrc7_CustomPatch: .res 1						; Keep track of the custom patch
0000F0r 1               var_ch_vrc7_Patch:		 .res 6						; VRC7 patch
0000F0r 1               var_ch_vrc7_DefPatch:	 .res 6
0000F0r 1               var_ch_vrc7_Fnum:		 .res 6 * 2
0000F0r 1               var_ch_vrc7_Bnum:		 .res 6
0000F0r 1               var_ch_vrc7_ActiveNote:	 .res 6
0000F0r 1               var_ch_vrc7_Command:	 .res 6						; 0 = halt, 1 = trigger, 80 = update
0000F0r 1               var_ch_vrc7_OldOctave:	 .res 1						; Temp variable for old octave when triggering new notes
0000F0r 1               var_ch_vrc7_EffPatch:	 .res 1						; V-command
0000F0r 1               .endif
0000F0r 1               
0000F0r 1               .ifdef USE_FDS
0000F0r 1               var_ch_Wave:			.res 1						; Index to wave table
0000F0r 1               var_ch_ModDelay:		.res 1
0000F0r 1               var_ch_ModDepth:		.res 1
0000F0r 1               var_ch_ModRate:			.res 2
0000F0r 1               var_ch_ModDelayTick:	.res 1
0000F0r 1               var_ch_ModEffDepth:		.res 1
0000F0r 1               var_ch_ModEffRateHi:	.res 1
0000F0r 1               var_ch_ModEffRateLo:	.res 1
0000F0r 1               var_ch_ModEffWritten:	.res 1
0000F0r 1               .endif
0000F0r 1               
0000F0r 1               ; End of variable space
0000F0r 1  xx           last_bss_var:			.res 1						; Not used
0000F1r 1               
0000F1r 1               
0000F1r 1               .segment "CODE"
000000r 1               
000000r 1               ; NSF entry addresses
000000r 1               
000000r 1               LOAD:
000000r 1               INIT:
000000r 1  4C rr rr     	jmp	ft_music_init
000003r 1               PLAY:
000003r 1  4C rr rr     	jmp	ft_music_play
000006r 1               
000006r 1               ; Disable channel in X, X = {00 : Square 1, 01 : Square 2, 02 : Triangle, 03 : Noise, 04 : DPCM}
000006r 1               ft_disable_channel:
000006r 1  BD rr rr     	lda ft_channel_mask, x
000009r 1  49 FF        	eor #$FF
00000Br 1  2D rr rr     	and var_Channels
00000Er 1  8D rr rr     	sta var_Channels
000011r 1  60           	rts
000012r 1               
000012r 1               ; Enable channel in X
000012r 1               ft_enable_channel:
000012r 1  BD rr rr     	lda ft_channel_mask, x
000015r 1  0D rr rr     	ora var_Channels
000018r 1  8D rr rr     	sta var_Channels
00001Br 1  A9 FF        	lda #$FF
00001Dr 1  E0 00        	cpx #$00
00001Fr 1  F0 05        	beq :+
000021r 1  E0 01        	cpx #$01
000023r 1  F0 05        	beq :++
000025r 1  60           	rts
000026r 1  8D rr rr     :	sta var_ch_PrevFreqHigh
000029r 1  60           	rts
00002Ar 1  8D rr rr     :	sta var_ch_PrevFreqHigh + 1
00002Dr 1  60           	rts
00002Er 1               
00002Er 1               ft_channel_mask:
00002Er 1  01 02 04 08  	.byte $01, $02, $04, $08, $10
000032r 1  10           
000033r 1               
000033r 1               ; The rest of the code
000033r 1               	.include "init.s"
000033r 2               ;
000033r 2               ; ft_sound_init
000033r 2               ;
000033r 2               ; Initializes the player and song number
000033r 2               ; a = song number
000033r 2               ; x = ntsc/pal
000033r 2               ;
000033r 2               ft_music_init:
000033r 2  0A           	asl a
000034r 2  20 rr rr     	jsr ft_load_song
000037r 2               	; Kill APU registers
000037r 2  A9 00        	lda #$00
000039r 2  A2 0B        	ldx #$0B
00003Br 2               @LoadRegs:
00003Br 2  9D 00 40     	sta $4000, x
00003Er 2  CA           	dex
00003Fr 2  D0 FA        	bne @LoadRegs
000041r 2  A2 06        	ldx #$06
000043r 2               @LoadRegs2:
000043r 2  9D 0D 40     	sta $400D, x
000046r 2  CA           	dex
000047r 2  D0 FA        	bne @LoadRegs2
000049r 2  A9 30        	lda #$30		; noise is special
00004Br 2  8D 0C 40     	sta $400C
00004Er 2  A9 0F        	lda #$0F
000050r 2  8D 15 40     	sta $4015		; APU control
000053r 2  A9 08        	lda #$08
000055r 2  8D 01 40     	sta $4001
000058r 2  8D 05 40     	sta $4005
00005Br 2  A9 C0        	lda #$C0
00005Dr 2  8D 17 40     	sta $4017
000060r 2  A9 40        	lda #$40
000062r 2  8D 17 40     	sta $4017		; Disable frame IRQs
000065r 2               
000065r 2  A9 FF        	lda #$FF		; Enable all channels
000067r 2  8D rr rr     	sta var_Channels
00006Ar 2               
00006Ar 2  8D rr rr     	sta var_ch_DPCM_EffPitch
00006Dr 2               
00006Dr 2               	; Reset some variables for the wave channels
00006Dr 2  A9 00        	lda #$00
00006Fr 2  AA           	tax
000070r 2  9D rr rr     :	sta var_ch_NoteCut, x
000073r 2  9D rr rr     	sta var_ch_Effect, x
000076r 2  9D rr rr     	sta var_ch_EffParam, x
000079r 2  9D rr rr     	sta var_ch_PortaToLo, x
00007Cr 2  9D rr rr     	sta var_ch_PortaToHi, x
00007Fr 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000082r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000085r 2  E8           	inx
000086r 2  E0 04        	cpx #WAVE_CHANS
000088r 2  D0 E6        	bne :-
00008Ar 2               
00008Ar 2               	; DPCM
00008Ar 2  8D rr rr     	sta var_ch_NoteCut + (CHANNELS - 1)
00008Dr 2               
00008Dr 2               .ifdef USE_MMC5
00008Dr 2               	lda #$03
00008Dr 2               	sta $5015		; Enable channels
00008Dr 2               .endif
00008Dr 2               
00008Dr 2  60           	rts
00008Er 2               
00008Er 2               ;
00008Er 2               ; Prepare the player for a song
00008Er 2               ;
00008Er 2               ; NSF music data header:
00008Er 2               ;
00008Er 2               ; - Song list, 2 bytes
00008Er 2               ; - Instrument list, 2 bytes
00008Er 2               ; - DPCM instrument list, 2 bytes
00008Er 2               ; - DPCM sample list, 2 bytes
00008Er 2               ; - Flags, 1 byte
00008Er 2               ; - Pointer to wave tables, 2 bytes, if FDS is enabled
00008Er 2               ; - NTSC speed divider
00008Er 2               ; - PAL speed divider
00008Er 2               ;
00008Er 2               ft_load_song:
00008Er 2  48           	pha
00008Fr 2               	; Get the header
00008Fr 2  AD rr rr     	lda ft_music_addr
000092r 2  85 rr        	sta var_Temp_Pointer
000094r 2  AD rr rr     	lda ft_music_addr + 1
000097r 2  85 rr        	sta var_Temp_Pointer + 1
000099r 2               
000099r 2               	; Read the header and store in RAM
000099r 2  A0 00        	ldy #$00
00009Br 2               @LoadAddresses:
00009Br 2  18           	clc
00009Cr 2  B1 rr        	lda (var_Temp_Pointer), y
00009Er 2  6D rr rr     	adc ft_music_addr
0000A1r 2  99 rr rr     	sta var_Song_list, y
0000A4r 2  C8           	iny
0000A5r 2  B1 rr        	lda (var_Temp_Pointer), y			; Song list offset, high addr
0000A7r 2  6D rr rr     	adc ft_music_addr + 1
0000AAr 2  99 rr rr     	sta var_Song_list, y
0000ADr 2  C8           	iny
0000AEr 2  C0 08        	cpy #$08							; 4 items
0000B0r 2  D0 E9        	bne @LoadAddresses
0000B2r 2               
0000B2r 2  B1 rr        	lda (var_Temp_Pointer), y			; Flags, 1 byte
0000B4r 2  8D rr rr     	sta var_SongFlags
0000B7r 2  C8           	iny
0000B8r 2               
0000B8r 2               .ifdef USE_FDS
0000B8r 2               	; Load FDS wave table pointer
0000B8r 2               	lda (var_Temp_Pointer), y
0000B8r 2               	adc ft_music_addr
0000B8r 2               	sta var_Wavetables
0000B8r 2               	iny
0000B8r 2               	lda (var_Temp_Pointer), y
0000B8r 2               	adc ft_music_addr + 1
0000B8r 2               	sta var_Wavetables + 1
0000B8r 2               	iny
0000B8r 2               .endif
0000B8r 2               
0000B8r 2  E0 01        	cpx #$01							; PAL / NTSC flag
0000BAr 2  F0 17        	beq @LoadPAL
0000BCr 2               .ifdef NTSC_PERIOD_TABLE
0000BCr 2               	; Load NTSC speed divider and frequency table
0000BCr 2  B1 rr        	lda (var_Temp_Pointer), y
0000BEr 2  C8           	iny
0000BFr 2  8D rr rr     	sta var_Tempo_Dec
0000C2r 2  B1 rr        	lda (var_Temp_Pointer), y
0000C4r 2  C8           	iny
0000C5r 2  8D rr rr     	sta var_Tempo_Dec + 1
0000C8r 2  A9 rr        	lda #<ft_notes_ntsc
0000CAr 2  85 rr        	sta var_Note_Table
0000CCr 2  A9 rr        	lda #>ft_notes_ntsc
0000CEr 2  85 rr        	sta var_Note_Table + 1
0000D0r 2               .endif
0000D0r 2  4C rr rr     	jmp @LoadDone
0000D3r 2               @LoadPAL:
0000D3r 2               .ifdef PAL_PERIOD_TABLE
0000D3r 2               	; Load PAL speed divider and frequency table
0000D3r 2  C8           	iny
0000D4r 2  C8           	iny
0000D5r 2  B1 rr        	lda (var_Temp_Pointer), y
0000D7r 2  C8           	iny
0000D8r 2  8D rr rr     	sta var_Tempo_Dec
0000DBr 2  B1 rr        	lda (var_Temp_Pointer), y
0000DDr 2  C8           	iny
0000DEr 2  8D rr rr     	sta var_Tempo_Dec + 1
0000E1r 2  A9 rr        	lda #<ft_notes_pal
0000E3r 2  85 rr        	sta var_Note_Table
0000E5r 2  A9 rr        	lda #>ft_notes_pal
0000E7r 2  85 rr        	sta var_Note_Table + 1
0000E9r 2               .endif
0000E9r 2                @LoadDone:
0000E9r 2  68           	pla
0000EAr 2  A8           	tay
0000EBr 2               	; Load the song
0000EBr 2  20 rr rr     	jsr ft_load_track
0000EEr 2               
0000EEr 2               	; Clear variables to zero
0000EEr 2               	; Important!
0000EEr 2  A2 01        	ldx #$01
0000F0r 2  8E rr rr     	stx var_PlayerFlags				; Player flags, bit 0 = playing
0000F3r 2  CA           	dex
0000F4r 2               @ClearChannels2:					; This clears the first four channels
0000F4r 2  A9 7F        	lda #$7F
0000F6r 2  9D rr rr     	sta var_ch_VolColumn, x
0000F9r 2  A9 80        	lda #$80
0000FBr 2  9D rr rr     	sta var_ch_FinePitch, x
0000FEr 2  A9 00        	lda #$00
000100r 2               	;
000100r 2               	;lda #$00
000100r 2  9D rr rr     	sta var_ch_VibratoSpeed, x
000103r 2  9D rr rr     	sta var_ch_TremoloSpeed, x
000106r 2  9D rr rr     	sta var_ch_Effect, x
000109r 2  9D rr rr     	sta var_ch_VolSlide, x
00010Cr 2  9D rr rr     	sta var_ch_NoteDelay, x
00010Fr 2  9D rr rr     	sta var_ch_ArpeggioCycle, x
000112r 2               	;
000112r 2  9D rr rr     	sta var_ch_Note, x
000115r 2  E8           	inx
000116r 2  E0 04        	cpx #(CHANNELS - 1)
000118r 2  D0 DA        	bne @ClearChannels2
00011Ar 2               
00011Ar 2  A2 FF        	ldx #$FF
00011Cr 2  8E rr rr     	stx var_ch_PrevFreqHigh			; Set prev freq to FF for Sq1 & 2
00011Fr 2  8E rr rr     	stx var_ch_PrevFreqHigh + 1
000122r 2               
000122r 2               .ifdef USE_DPCM
000122r 2  A9 00            lda #$00
000124r 2  8D rr rr         sta var_ch_DPCM_Offset
000127r 2               .endif
000127r 2               .ifdef USE_MMC5
000127r 2               	stx var_ch_PrevFreqHighMMC5
000127r 2               	stx var_ch_PrevFreqHighMMC5 + 1
000127r 2               .endif
000127r 2               .ifdef USE_VRC7
000127r 2               	stx var_ch_vrc7_CustomPatch
000127r 2               .endif
000127r 2               
000127r 2  E8           	inx								; Jump to the first frame
000128r 2  8E rr rr     	stx var_Current_Frame
00012Br 2  20 rr rr     	jsr ft_load_frame
00012Er 2               
00012Er 2  20 rr rr     	jsr ft_calculate_speed
000131r 2               	;jsr ft_restore_speed
000131r 2               
000131r 2  A9 00        	lda #$00
000133r 2  8D rr rr     	sta var_Tempo_Accum
000136r 2  8D rr rr     	sta var_Tempo_Accum + 1
000139r 2               
000139r 2  60           	rts
00013Ar 2               
00013Ar 2               ;
00013Ar 2               ; Load the track number in A
00013Ar 2               ;
00013Ar 2               ; Track headers:
00013Ar 2               ;
00013Ar 2               ;	- Frame list address, 2 bytes
00013Ar 2               ;	- Number of frames, 1 byte
00013Ar 2               ;	- Pattern length, 1 byte
00013Ar 2               ;	- Speed, 1 byte
00013Ar 2               ;	- Tempo, 1 byte
00013Ar 2               ;
00013Ar 2               ft_load_track:
00013Ar 2               	; Load track header address
00013Ar 2  AD rr rr     	lda var_Song_list
00013Dr 2  85 rr        	sta var_Temp16
00013Fr 2  AD rr rr     	lda var_Song_list + 1
000142r 2  85 rr        	sta var_Temp16 + 1
000144r 2               
000144r 2               	; Get the real address, song number * 2 will be in Y here
000144r 2  18           	clc
000145r 2  B1 rr        	lda (var_Temp16), y
000147r 2  6D rr rr     	adc ft_music_addr
00014Ar 2  85 rr        	sta var_Temp_Pointer
00014Cr 2  C8           	iny
00014Dr 2  B1 rr        	lda (var_Temp16), y
00014Fr 2  6D rr rr     	adc ft_music_addr + 1
000152r 2  85 rr        	sta var_Temp_Pointer + 1
000154r 2               
000154r 2               	; Read header
000154r 2  A9 00        	lda #$00
000156r 2  AA           	tax
000157r 2  A8           	tay
000158r 2  18           	clc
000159r 2  B1 rr        	lda (var_Temp_Pointer), y			; Frame offset, low addr
00015Br 2  6D rr rr     	adc ft_music_addr
00015Er 2  8D rr rr     	sta var_Frame_List
000161r 2  C8           	iny
000162r 2  B1 rr        	lda (var_Temp_Pointer), y			; Frame offset, high addr
000164r 2  6D rr rr     	adc ft_music_addr + 1
000167r 2  8D rr rr     	sta var_Frame_List + 1
00016Ar 2  C8           	iny
00016Br 2               @ReadLoop:
00016Br 2  B1 rr        	lda (var_Temp_Pointer), y			; Frame count
00016Dr 2  9D rr rr     	sta var_Frame_Count, x
000170r 2  C8           	iny
000171r 2  E8           	inx
000172r 2  E0 06        	cpx #$06
000174r 2  D0 F5        	bne @ReadLoop
000176r 2               
000176r 2  60           	rts
000177r 2               
000177r 2               ;
000177r 2               ; Load the frame in A for all channels
000177r 2               ;
000177r 2               ft_load_frame:
000177r 2               .ifdef USE_BANKSWITCH
000177r 2  48           	pha
000178r 2  AD rr rr     	lda var_InitialBank
00017Br 2  F0 03        	beq :+
00017Dr 2  8D FB 5F     	sta $5FFB
000180r 2  68           :	pla
000181r 2               .endif
000181r 2               
000181r 2               	; Get the entry in the frame list
000181r 2  0A           	asl A					; Multiply by two
000182r 2  18           	clc						; And add the frame list addr to get
000183r 2  6D rr rr     	adc var_Frame_List		; the pattern list addr
000186r 2  85 rr        	sta var_Temp16
000188r 2  A9 00        	lda #$00
00018Ar 2  A8           	tay
00018Br 2  AA           	tax
00018Cr 2  6D rr rr     	adc var_Frame_List + 1
00018Fr 2  85 rr        	sta var_Temp16 + 1
000191r 2               	; Get the entry in the pattern list
000191r 2  B1 rr        	lda (var_Temp16), y
000193r 2  6D rr rr     	adc ft_music_addr
000196r 2  85 rr        	sta var_Temp_Pointer
000198r 2  C8           	iny
000199r 2  B1 rr        	lda (var_Temp16), y
00019Br 2  6D rr rr     	adc ft_music_addr + 1
00019Er 2  85 rr        	sta var_Temp_Pointer + 1
0001A0r 2               	; Iterate through the channels, x = channel
0001A0r 2  A0 00        	ldy #$00							; Y = address
0001A2r 2  8E rr rr     	stx var_Pattern_Pos
0001A5r 2               @LoadPatternAddr:
0001A5r 2  18           	clc
0001A6r 2  B1 rr        	lda (var_Temp_Pointer), y			; Load the pattern address for the channel
0001A8r 2  6D rr rr     	adc ft_music_addr
0001ABr 2  9D rr rr     	sta var_ch_PatternAddrLo, x
0001AEr 2  C8           	iny
0001AFr 2  B1 rr        	lda (var_Temp_Pointer), y			; Pattern address, high byte
0001B1r 2  6D rr rr     	adc ft_music_addr + 1
0001B4r 2  9D rr rr     	sta var_ch_PatternAddrHi, x
0001B7r 2  C8           	iny
0001B8r 2  A9 00        	lda #$00
0001BAr 2  9D rr rr     	sta var_ch_NoteDelay, x
0001BDr 2  9D rr rr     	sta var_ch_Delay, x
0001C0r 2               ;	sta var_ch_LoopCounter, x
0001C0r 2  A9 FF        	lda #$FF
0001C2r 2  9D rr rr     	sta var_ch_DefaultDelay, x
0001C5r 2  E8           	inx
0001C6r 2  E0 05        	cpx #CHANNELS
0001C8r 2  D0 DB        	bne @LoadPatternAddr
0001CAr 2               ; Bankswitch values
0001CAr 2               .ifdef USE_BANKSWITCH
0001CAr 2  AD rr rr     	lda var_SongFlags					; Check bankswitch flag
0001CDr 2  29 01        	and #$01
0001CFr 2  F0 0D        	beq @SkipBankValues					; Skip if no bankswitch info is stored
0001D1r 2  A2 00        	ldx #$00
0001D3r 2               @LoadBankValues:
0001D3r 2  B1 rr        	lda (var_Temp_Pointer), y			; Pattern bank number
0001D5r 2  9D rr rr     	sta var_ch_Bank, x
0001D8r 2  C8           	iny
0001D9r 2  E8           	inx
0001DAr 2  E0 05        	cpx #CHANNELS
0001DCr 2  D0 F5        	bne @LoadBankValues
0001DEr 2               @SkipBankValues:
0001DEr 2               .endif
0001DEr 2               
0001DEr 2               .ifdef ENABLE_ROW_SKIP
0001DEr 2               
0001DEr 2  AD rr rr     	lda var_SkipTo
0001E1r 2  F0 03        	beq @FirstRow
0001E3r 2  4C rr rr     	jmp ft_SkipToRow
0001E6r 2               @FirstRow:
0001E6r 2  60           	rts
0001E7r 2               
0001E7r 2               ; Skip to a certain row, this is NOT recommended in songs when CPU time is critical!!
0001E7r 2               ;
0001E7r 2               ft_SkipToRow:
0001E7r 2  48           	pha									; Save row count
0001E8r 2  A2 00        	ldx #$00							; x = channel
0001EAr 2               @ChannelLoop:
0001EAr 2               
0001EAr 2  68           	pla
0001EBr 2  85 rr        	sta var_Temp2						; Restore row count
0001EDr 2  48           	pha
0001EEr 2               
0001EEr 2  A9 00        	lda #$00
0001F0r 2  9D rr rr     	sta var_ch_NoteDelay, x
0001F3r 2               
0001F3r 2               @RowLoop:
0001F3r 2  A0 00        	ldy #$00
0001F5r 2  BD rr rr     	lda var_ch_PatternAddrLo, x
0001F8r 2  85 rr        	sta var_Temp_Pointer
0001FAr 2  BD rr rr     	lda var_ch_PatternAddrHi, x
0001FDr 2  85 rr        	sta var_Temp_Pointer + 1
0001FFr 2               
0001FFr 2               @ReadNote:
0001FFr 2  BD rr rr     	lda var_ch_NoteDelay, x				; First check if in the middle of a row delay
000202r 2  F0 06        	beq @NoRowDelay
000204r 2  DE rr rr     	dec var_ch_NoteDelay, x				; Decrease one
000207r 2  4C rr rr     	jmp @RowIsDone
00020Ar 2               
00020Ar 2               @NoRowDelay:
00020Ar 2               	; Read a row
00020Ar 2  B1 rr        	lda (var_Temp_Pointer), y
00020Cr 2  30 35        	bmi @Effect
00020Er 2               
00020Er 2  BD rr rr     	lda var_ch_DefaultDelay, x
000211r 2  C9 FF        	cmp #$FF
000213r 2  D0 0A        	bne @LoadDefaultDelay
000215r 2  C8           	iny
000216r 2  B1 rr        	lda (var_Temp_Pointer), y
000218r 2  C8           	iny
000219r 2               
000219r 2  9D rr rr     	sta var_ch_NoteDelay, x
00021Cr 2  4C rr rr     	jmp @RowIsDone
00021Fr 2               @LoadDefaultDelay:
00021Fr 2  C8           	iny
000220r 2  9D rr rr     	sta var_ch_NoteDelay, x				; Store default delay
000223r 2               @RowIsDone:
000223r 2               	; Save the new address
000223r 2  18           	clc
000224r 2  98           	tya
000225r 2  65 rr        	adc var_Temp_Pointer
000227r 2  9D rr rr     	sta var_ch_PatternAddrLo, x
00022Ar 2  A9 00        	lda #$00
00022Cr 2  65 rr        	adc var_Temp_Pointer + 1
00022Er 2  9D rr rr     	sta var_ch_PatternAddrHi, x
000231r 2               
000231r 2  C6 rr        	dec var_Temp2						; Next row
000233r 2  D0 BE        	bne @RowLoop
000235r 2               
000235r 2  E8           	inx									; Next channel
000236r 2  E0 05        	cpx #CHANNELS
000238r 2  D0 B0        	bne @ChannelLoop
00023Ar 2               
00023Ar 2  68           	pla									; fix the stack
00023Br 2  18           	clc
00023Cr 2  6D rr rr     	adc var_Pattern_Pos
00023Fr 2  8D rr rr     	sta var_Pattern_Pos
000242r 2  60           	rts
000243r 2               
000243r 2               @Effect:
000243r 2  C9 9E        	cmp #$9E
000245r 2  F0 19        	beq @EffectDuration
000247r 2  C9 A0        	cmp #$A0
000249r 2  F0 1F        	beq @EffectNoDuration
00024Br 2  48           	pha
00024Cr 2  C9 8E        	cmp #$8E							; remove pitch slide
00024Er 2  F0 0B        	beq @OneByteCommand
000250r 2  29 F0        	and #$F0
000252r 2  C9 F0        	cmp #$F0							; See if volume
000254r 2  F0 05        	beq @OneByteCommand
000256r 2  C9 E0        	cmp #$E0							; See if a quick instrument command
000258r 2  F0 01        	beq @OneByteCommand
00025Ar 2  C8           	iny									; Command takes two bytes
00025Br 2               @OneByteCommand:						; Command takes one byte
00025Br 2  C8           	iny
00025Cr 2  68           	pla
00025Dr 2  4C rr rr     	jmp @ReadNote						; A new command or note is immediately following
000260r 2               @EffectDuration:
000260r 2  C8           	iny
000261r 2  B1 rr        	lda (var_Temp_Pointer), y
000263r 2  C8           	iny
000264r 2  9D rr rr     	sta var_ch_DefaultDelay, x
000267r 2  4C rr rr     	jmp @ReadNote
00026Ar 2               @EffectNoDuration:
00026Ar 2  C8           	iny
00026Br 2  A9 FF        	lda #$FF
00026Dr 2  9D rr rr     	sta var_ch_DefaultDelay, x
000270r 2  4C rr rr     	jmp @ReadNote
000273r 2               
000273r 2               .else
000273r 2               	rts
000273r 2               .endif
000273r 2               
000273r 1               	.include "player.s"
000273r 2               ;
000273r 2               ; ft_music_play
000273r 2               ;
000273r 2               ; The player routine
000273r 2               ;
000273r 2               ft_music_play:
000273r 2  AD rr rr     	lda var_PlayerFlags					; Skip if player is disabled
000276r 2  D0 01        	bne :+
000278r 2  60           	rts									; Not playing, return
000279r 2               :
000279r 2               	; Run delayed channels
000279r 2  A2 00        	ldx #$00
00027Br 2               @ChanLoop:
00027Br 2  BD rr rr     	lda var_ch_Delay, x
00027Er 2  F0 0B        	beq @SkipDelay
000280r 2  38           	sec
000281r 2  E9 01        	sbc #$01
000283r 2  9D rr rr     	sta var_ch_Delay, x
000286r 2  D0 03        	bne @SkipDelay
000288r 2  20 rr rr     	jsr ft_read_pattern					; Read the delayed note
00028Br 2               @SkipDelay:
00028Br 2  E8           	inx
00028Cr 2  E0 05        	cpx #CHANNELS
00028Er 2  D0 EB        	bne @ChanLoop
000290r 2               	; Speed division
000290r 2  AD rr rr     	lda var_Tempo_Accum + 1
000293r 2  30 08        	bmi ft_do_row_update				; Counter < 0
000295r 2  0D rr rr     	ora var_Tempo_Accum
000298r 2  F0 03        	beq ft_do_row_update				; Counter = 0
00029Ar 2  4C rr rr     	jmp ft_skip_row_update
00029Dr 2               	; Read a row
00029Dr 2               ft_do_row_update:
00029Dr 2               
00029Dr 2               .ifdef USE_DPCM
00029Dr 2  A9 00        	lda #$00
00029Fr 2  8D rr rr     	sta var_ch_DPCM_Retrig
0002A2r 2               .endif
0002A2r 2               .ifdef USE_FDS
0002A2r 2                   lda #$00
0002A2r 2                   sta var_ch_ModEffWritten
0002A2r 2               .endif
0002A2r 2               
0002A2r 2               	; Switches to new frames are delayed to next row to resolve issues with delayed notes.
0002A2r 2               	; It won't work if new pattern adresses are loaded before the delayed note is played
0002A2r 2  AD rr rr     	lda var_Load_Frame
0002A5r 2  F0 0B        	beq @SkipFrameLoad
0002A7r 2  A9 00        	lda #$00
0002A9r 2  8D rr rr     	sta var_Load_Frame
0002ACr 2  AD rr rr     	lda var_Current_Frame
0002AFr 2  20 rr rr     	jsr ft_load_frame
0002B2r 2               @SkipFrameLoad:
0002B2r 2               
0002B2r 2  A9 00        	lda #$00
0002B4r 2  8D rr rr     	sta var_Jump
0002B7r 2  8D rr rr     	sta var_Skip
0002BAr 2               
0002BAr 2               	; Read one row from all patterns
0002BAr 2  A2 00        	ldx #$00
0002BCr 2               ft_read_channels:
0002BCr 2               @UpdateChan:
0002BCr 2  BD rr rr     	lda var_ch_Delay, x
0002BFr 2  F0 08        	beq :+
0002C1r 2  A9 00        	lda #$00
0002C3r 2  9D rr rr     	sta var_ch_Delay, x
0002C6r 2  20 rr rr     	jsr ft_read_pattern
0002C9r 2  20 rr rr     :	jsr ft_read_pattern					; Get new notes
0002CCr 2  BD rr rr     	lda var_ch_NoteCut, x
0002CFr 2  29 7F        	and #$7F
0002D1r 2  9D rr rr     	sta var_ch_NoteCut, x
0002D4r 2  E8           	inx
0002D5r 2  E0 05        	cpx #CHANNELS
0002D7r 2  D0 E3        	bne ft_read_channels
0002D9r 2               
0002D9r 2               .ifdef USE_FDS
0002D9r 2                   lda var_ch_ModEffWritten
0002D9r 2               	and #$01
0002D9r 2                   beq :+
0002D9r 2                   ; FDS modulation depth
0002D9r 2                   lda var_ch_ModEffDepth
0002D9r 2                   sta var_ch_ModDepth
0002D9r 2               :   lda var_ch_ModEffWritten
0002D9r 2               	and #$02
0002D9r 2                   beq :+
0002D9r 2                   ; FDS modulation rate high
0002D9r 2                   lda var_ch_ModEffRateHi
0002D9r 2                   sta var_ch_ModRate + 1
0002D9r 2               :   lda var_ch_ModEffWritten
0002D9r 2               	and #$04
0002D9r 2                   beq :+
0002D9r 2                   ; FDS modulation rate low
0002D9r 2                   lda var_ch_ModEffRateLo
0002D9r 2                   sta var_ch_ModRate + 0
0002D9r 2               :
0002D9r 2                	lda #$00
0002D9r 2                	sta var_ch_ModEffWritten
0002D9r 2               .endif
0002D9r 2               
0002D9r 2               	; Should jump?
0002D9r 2  AD rr rr     	lda var_Jump
0002DCr 2  F0 0E        	beq @NoJump
0002DEr 2               	; Yes, jump
0002DEr 2  38           	sec
0002DFr 2  E9 01        	sbc #$01
0002E1r 2  8D rr rr     	sta var_Current_Frame
0002E4r 2               ;	jsr ft_load_frame
0002E4r 2  A9 01        	lda #$01
0002E6r 2  8D rr rr     	sta var_Load_Frame
0002E9r 2               
0002E9r 2  4C rr rr     	jmp @NoPatternEnd
0002ECr 2               @NoJump:
0002ECr 2               	; Should skip?
0002ECr 2  AD rr rr     	lda var_Skip
0002EFr 2  F0 26        	beq @NoSkip
0002F1r 2               	; Yes, skip
0002F1r 2  38           	sec
0002F2r 2  E9 01        	sbc #$01
0002F4r 2               .ifdef ENABLE_ROW_SKIP
0002F4r 2               	; Store next row number in Temp2
0002F4r 2  8D rr rr     	sta var_SkipTo
0002F7r 2               .endif
0002F7r 2  EE rr rr     	inc var_Current_Frame
0002FAr 2  AD rr rr     	lda var_Current_Frame
0002FDr 2  CD rr rr     	cmp var_Frame_Count
000300r 2  F0 08        	beq @RestartSong
000302r 2               ;	jsr ft_load_frame
000302r 2  A9 01        	lda #$01
000304r 2  8D rr rr     	sta var_Load_Frame
000307r 2               
000307r 2  4C rr rr     	jmp @NoPatternEnd
00030Ar 2               @RestartSong:
00030Ar 2  A9 00        	lda #$00
00030Cr 2  8D rr rr     	sta var_Current_Frame
00030Fr 2               ;	jsr ft_load_frame
00030Fr 2  A9 01        	lda #$01
000311r 2  8D rr rr     	sta var_Load_Frame
000314r 2               
000314r 2  4C rr rr     	jmp @NoPatternEnd
000317r 2               @NoSkip:
000317r 2               	; Current row in all channels are processed, update info
000317r 2  EE rr rr     	inc var_Pattern_Pos
00031Ar 2  AD rr rr     	lda var_Pattern_Pos					; See if end is reached
00031Dr 2  CD rr rr     	cmp var_Pattern_Length
000320r 2  D0 1A        	bne @NoPatternEnd
000322r 2               	; End of current frame, load next
000322r 2  EE rr rr     	inc var_Current_Frame
000325r 2  AD rr rr     	lda var_Current_Frame
000328r 2  CD rr rr     	cmp var_Frame_Count
00032Br 2  F0 06        	beq @ResetFrame
00032Dr 2  8D rr rr     	sta var_Load_Frame
000330r 2  4C rr rr     	jmp @NoPatternEnd
000333r 2               @ResetFrame:
000333r 2  A2 00        	ldx #$00
000335r 2  8E rr rr     	stx var_Current_Frame
000338r 2  E8           	inx
000339r 2  8E rr rr     	stx var_Load_Frame
00033Cr 2               
00033Cr 2               @NoPatternEnd:
00033Cr 2  20 rr rr     	jsr ft_restore_speed				; Reset frame divider counter
00033Fr 2               ft_skip_row_update:
00033Fr 2               	; Speed division
00033Fr 2  38           	sec
000340r 2  AD rr rr     	lda var_Tempo_Accum					; Decrement speed counter
000343r 2  ED rr rr     	sbc var_Tempo_Count
000346r 2  8D rr rr     	sta var_Tempo_Accum
000349r 2  AD rr rr     	lda var_Tempo_Accum + 1
00034Cr 2  ED rr rr     	sbc var_Tempo_Count + 1
00034Fr 2  8D rr rr     	sta var_Tempo_Accum + 1
000352r 2               
000352r 2               	; Note cut effect (Sxx)
000352r 2  A2 00        	ldx #$00
000354r 2  BD rr rr     :	lda var_ch_NoteCut, x
000357r 2  F0 0B        	beq :+
000359r 2  38           	sec
00035Ar 2  E9 01        	sbc #$01
00035Cr 2  9D rr rr     	sta var_ch_NoteCut, x
00035Fr 2  D0 03        	bne :+
000361r 2  9D rr rr     	sta var_ch_Note, x
000364r 2  E8           :	inx
000365r 2  E0 05        	cpx #CHANNELS
000367r 2  D0 EB        	bne :--
000369r 2               
000369r 2               	; Update channel instruments and effects
000369r 2  A2 00        	ldx #$00
00036Br 2               
00036Br 2               ; Loop through wave channels
00036Br 2               ft_loop_channels:
00036Br 2               
00036Br 2               	; Do channel effects, like portamento and vibrato
00036Br 2  20 rr rr     	jsr ft_run_effects
00036Er 2               
00036Er 2               	; Instrument sequences
00036Er 2  BD rr rr     	lda var_ch_Note, x
000371r 2  F0 03        	beq :+
000373r 2  20 rr rr     	jsr ft_update_channel				; Update instruments
000376r 2  20 rr rr     :	jsr	ft_calc_freq
000379r 2               
000379r 2  E8           	inx
00037Ar 2               	;cpx #WAVE_CHANS		; Skip DPCM
00037Ar 2  E0 04        	cpx #EFF_CHANS
00037Cr 2  D0 ED        	bne ft_loop_channels
00037Er 2               
00037Er 2               	; Finally update APU and expansion chip registers
00037Er 2  20 rr rr     	jsr ft_update_apu
000381r 2               .ifdef USE_VRC6
000381r 2               	jsr	ft_update_vrc6
000381r 2               .endif
000381r 2               .ifdef USE_MMC5
000381r 2               	jsr	ft_update_mmc5
000381r 2               .endif
000381r 2               .ifdef USE_VRC7
000381r 2               	jsr ft_update_vrc7
000381r 2               .endif
000381r 2               .ifdef USE_FDS
000381r 2               	jsr ft_update_fds
000381r 2               .endif
000381r 2               
000381r 2               	; End of music routine, return
000381r 2  60           	rts
000382r 2               
000382r 2               
000382r 2               ; Process a pattern row in channel X
000382r 2               ft_read_pattern:
000382r 2  BC rr rr     	ldy var_ch_NoteDelay, x				; First check if in the middle of a row delay
000385r 2  F0 06        	beq :+
000387r 2  88           	dey
000388r 2  98           	tya
000389r 2  9D rr rr     	sta var_ch_NoteDelay, x
00038Cr 2  60           	rts									; And skip
00038Dr 2  8C rr rr     :	sty var_Sweep						; Y = 0
000390r 2               .ifdef USE_BANKSWITCH
000390r 2               	; First setup the bank
000390r 2  BD rr rr     	lda var_ch_Bank, x
000393r 2  F0 03        	beq :+
000395r 2  8D FB 5F     	sta $5FFB							; Will always be the last bank before DPCM
000398r 2               :	; Go on
000398r 2               .endif
000398r 2  A9 0F        	lda #$0F
00039Ar 2               .ifdef USE_FDS
00039Ar 2               	cpx #FDS_CHANNEL
00039Ar 2               	bne :+
00039Ar 2               	lda #$1F							; FDS max vol is 31
00039Ar 2               :
00039Ar 2               .endif
00039Ar 2  8D rr rr     	sta var_VolTemp
00039Dr 2  BD rr rr     	lda var_ch_PatternAddrLo, x			; Load pattern address
0003A0r 2  85 rr        	sta var_Temp_Pattern
0003A2r 2  BD rr rr     	lda var_ch_PatternAddrHi, x
0003A5r 2  85 rr        	sta var_Temp_Pattern + 1
0003A7r 2               .ifdef USE_VRC7
0003A7r 2                   lda #$FF
0003A7r 2                   sta var_ch_vrc7_EffPatch
0003A7r 2               .endif
0003A7r 2               
0003A7r 2               ft_read_note:
0003A7r 2  B1 rr        	lda (var_Temp_Pattern), y			; Read pattern command
0003A9r 2  10 03        	bpl :+
0003ABr 2  4C rr rr     	jmp @Effect
0003AEr 2  F0 63        :	beq @JumpToDone						; Rest
0003B0r 2  C9 7F        	cmp #$7F
0003B2r 2               ;	beq @NoteOff						; Note off
0003B2r 2  D0 03        	bne :+
0003B4r 2  4C rr rr     	jmp @NoteOff
0003B7r 2  C9 7E        :	cmp #$7E
0003B9r 2               ;	beq @NoteRelease					; Note release
0003B9r 2  D0 03        	bne :+
0003BBr 2  4C rr rr     	jmp @NoteRelease
0003BEr 2               :
0003BEr 2               	; Read a note
0003BEr 2  9D rr rr     	sta var_ch_Note, x					; Note on
0003C1r 2  20 rr rr     	jsr ft_translate_freq
0003C4r 2               
0003C4r 2  BD rr rr     	lda var_ch_NoteCut, x
0003C7r 2  30 05        	bmi :+
0003C9r 2  A9 00        	lda #$00
0003CBr 2  9D rr rr     	sta var_ch_NoteCut, x				; Reset note cuts
0003CEr 2               :
0003CEr 2               .ifdef USE_DPCM
0003CEr 2  E0 04        	cpx #DPCM_CHANNEL					; Break here if DPCM
0003D0r 2  D0 03        	bne :+
0003D2r 2  4C rr rr     	jmp @ReadIsDone
0003D5r 2               :	; DPCM skip
0003D5r 2               .endif
0003D5r 2               .ifdef USE_VRC7
0003D5r 2               	cpx #VRC7_CHANNEL
0003D5r 2               	bcc :+								; <
0003D5r 2               	cpx #VRC7_CHANNEL + 6
0003D5r 2               	bcs :+								; >
0003D5r 2               	jsr ft_vrc7_trigger
0003D5r 2               	jmp @ReadIsDone
0003D5r 2               :	; VRC7 skip
0003D5r 2               .endif
0003D5r 2  20 rr rr     	jsr ft_reset_instrument
0003D8r 2  A9 00        	lda #$00
0003DAr 2  9D rr rr     	sta var_ch_State, x
0003DDr 2  AD rr rr     	lda var_VolTemp
0003E0r 2  9D rr rr     	sta var_ch_Volume, x
0003E3r 2  A9 00        	lda #$00
0003E5r 2               ;	sta var_ch_ArpeggioCycle, x
0003E5r 2               
0003E5r 2  BD rr rr     	lda var_ch_DutyCycle, x
0003E8r 2  29 F0        	and #$F0
0003EAr 2  9D rr rr     	sta var_ch_DutyCycle, x
0003EDr 2  4A           	lsr a
0003EEr 2  4A           	lsr a
0003EFr 2  4A           	lsr a
0003F0r 2  4A           	lsr a
0003F1r 2  1D rr rr     	ora var_ch_DutyCycle, x
0003F4r 2  9D rr rr     	sta var_ch_DutyCycle, x
0003F7r 2               
0003F7r 2               	; Reset sweep
0003F7r 2  BD rr rr     	lda var_ch_Effect,x
0003FAr 2  C9 06        	cmp #EFF_SLIDE_UP
0003FCr 2  F0 04        	beq :+
0003FEr 2  C9 08        	cmp #EFF_SLIDE_DOWN
000400r 2  D0 05        	bne :++
000402r 2  A9 00        :	lda #EFF_NONE
000404r 2  9D rr rr     	sta var_ch_Effect,x
000407r 2               :
000407r 2               
000407r 2  E0 02        	cpx #$02							; Skip if not square
000409r 2  90 03        	bcc :+
00040Br 2  4C rr rr     	jmp @ReadIsDone
00040Er 2  A9 00        :	lda #$00
000410r 2  9D rr rr     	sta var_ch_Sweep, x					; Reset sweep
000413r 2               @JumpToDone:
000413r 2  4C rr rr     	jmp @ReadIsDone
000416r 2               @NoteRelease:
000416r 2  A9 01        	lda #$01
000418r 2  9D rr rr     	sta var_ch_State, x
00041Br 2               .ifdef USE_DPCM
00041Br 2  E0 04        	cpx #DPCM_CHANNEL					; Skip if DPCM
00041Dr 2  D0 08        	bne :+
00041Fr 2  A9 FF        	lda #$FF
000421r 2  9D rr rr     	sta var_ch_Note, x
000424r 2  4C rr rr     	jmp @ReadIsDone
000427r 2               :
000427r 2               .endif
000427r 2               .ifdef USE_VRC7
000427r 2                   cpx #VRC7_CHANNEL
000427r 2                   bcs @JumpToDone
000427r 2               .endif
000427r 2  20 rr rr     	jsr ft_instrument_release
00042Ar 2  4C rr rr     	jmp @ReadIsDone
00042Dr 2               @NoteOff:
00042Dr 2  A9 00        	lda #$00
00042Fr 2  9D rr rr     	sta var_ch_Note, x
000432r 2               .ifdef USE_DPCM
000432r 2  E0 04        	cpx #DPCM_CHANNEL					; Skip if DPCM
000434r 2  D0 03        	bne :+
000436r 2  4C rr rr     	jmp @ReadIsDone
000439r 2               :
000439r 2               .endif
000439r 2               .ifdef USE_VRC7
000439r 2               	cpx #VRC7_CHANNEL					; Skip if not VRC7 channel
000439r 2               	bcc :+
000439r 2               	cpx #VRC7_CHANNEL + 6
000439r 2               	bcs :+
000439r 2               	lda #$00							; Halt VRC7 channel
000439r 2               	sta var_ch_vrc7_Command - VRC7_CHANNEL, x
000439r 2               
000439r 2               	jmp @ReadIsDone
000439r 2               :
000439r 2               .endif
000439r 2  9D rr rr     	sta var_ch_Volume, x
00043Cr 2  9D rr rr     	sta var_ch_PortaToLo, x
00043Fr 2  9D rr rr     	sta var_ch_PortaToHi, x
000442r 2  E0 02        	cpx #$02							; Skip all over square channels
000444r 2  B0 05        	bcs :+
000446r 2  A9 FF        	lda #$FF
000448r 2  9D rr rr     	sta var_ch_PrevFreqHigh, x
00044Br 2  4C rr rr     :	jmp @ReadIsDone
00044Er 2               @VolumeCommand:							; Handle volume
00044Er 2  68           	pla
00044Fr 2  0A           	asl a
000450r 2  0A           	asl a
000451r 2  0A           	asl a
000452r 2               	;asl a
000452r 2  29 78        	and #$78
000454r 2  9D rr rr     	sta var_ch_VolColumn, x
000457r 2  C8           	iny
000458r 2  4C rr rr     	jmp ft_read_note
00045Br 2               @InstCommand:							; Instrument change
00045Br 2  68           	pla
00045Cr 2  29 0F        	and #$0F
00045Er 2  0A           	asl a
00045Fr 2  20 rr rr     	jsr ft_load_instrument
000462r 2  C8           	iny
000463r 2  4C rr rr     	jmp ft_read_note
000466r 2               @Effect:
000466r 2  48           	pha
000467r 2  29 F0        	and #$F0
000469r 2  C9 F0        	cmp #$F0							; See if volume
00046Br 2  F0 E1        	beq @VolumeCommand
00046Dr 2  C9 E0        	cmp #$E0							; See if a quick instrument command
00046Fr 2  F0 EA        	beq @InstCommand
000471r 2  68           	pla
000472r 2  29 7F        	and #$7F							; Look up the command address
000474r 2  84 rr        	sty var_Temp						; from the command table
000476r 2  A8           	tay
000477r 2  B9 rr rr     	lda ft_command_table, y
00047Ar 2  85 rr        	sta var_Temp_Pointer
00047Cr 2  C8           	iny
00047Dr 2  B9 rr rr     	lda ft_command_table, y
000480r 2  85 rr        	sta var_Temp_Pointer + 1
000482r 2  A4 rr        	ldy var_Temp
000484r 2  C8           	iny
000485r 2  6C rr rr     	jmp (var_Temp_Pointer)				; And jump there
000488r 2               @LoadDefaultDelay:
000488r 2  9D rr rr     	sta var_ch_NoteDelay, x				; Store default delay
00048Br 2  4C rr rr     	jmp ft_read_is_done
00048Er 2               @ReadIsDone:
00048Er 2  BD rr rr     	lda var_ch_DefaultDelay, x			; See if there's a default delay
000491r 2  C9 FF        	cmp #$FF
000493r 2  D0 F3        	bne @LoadDefaultDelay				; If so then use it
000495r 2  C8           	iny
000496r 2  B1 rr        	lda (var_Temp_Pattern), y			; A note is immediately followed by the amount of rows until next note
000498r 2  9D rr rr     	sta var_ch_NoteDelay, x
00049Br 2               ft_read_is_done:
00049Br 2  18           	clc									; Store pattern address
00049Cr 2  C8           	iny
00049Dr 2  98           	tya
00049Er 2  65 rr        	adc var_Temp_Pattern
0004A0r 2  9D rr rr     	sta var_ch_PatternAddrLo, x
0004A3r 2  A9 00        	lda #$00
0004A5r 2  65 rr        	adc var_Temp_Pattern + 1
0004A7r 2  9D rr rr     	sta var_ch_PatternAddrHi, x
0004AAr 2               
0004AAr 2  AD rr rr     	lda var_Sweep						; Check sweep
0004ADr 2  F0 0B        	beq @EndPatternFetch
0004AFr 2  9D rr rr     	sta var_ch_Sweep, x					; Store sweep, only used for square 1 and 2
0004B2r 2  A9 00        	lda #$00
0004B4r 2  8D rr rr     	sta var_Sweep
0004B7r 2  9D rr rr     	sta var_ch_PrevFreqHigh, x
0004BAr 2               @EndPatternFetch:
0004BAr 2  60           	rts
0004BBr 2               
0004BBr 2               ; Read pattern to A and move to next byte
0004BBr 2               ft_get_pattern_byte:
0004BBr 2  B1 rr        	lda (var_Temp_Pattern), y			; Get the instrument number
0004BDr 2  48           	pha
0004BEr 2  C8           	iny
0004BFr 2  68           	pla
0004C0r 2  60           	rts
0004C1r 2               
0004C1r 2               ;
0004C1r 2               ; Command table
0004C1r 2               ;
0004C1r 2               ft_command_table:
0004C1r 2  rr rr        	.word ft_cmd_instrument
0004C3r 2  rr rr        	.word ft_cmd_speed
0004C5r 2  rr rr        	.word ft_cmd_jump
0004C7r 2  rr rr        	.word ft_cmd_skip
0004C9r 2  rr rr        	.word ft_cmd_halt
0004CBr 2  rr rr        	.word ft_cmd_effvolume
0004CDr 2  rr rr        	.word ft_cmd_portamento
0004CFr 2  rr rr        	.word ft_cmd_porta_up
0004D1r 2  rr rr        	.word ft_cmd_porta_down
0004D3r 2  rr rr        	.word ft_cmd_sweep
0004D5r 2  rr rr        	.word ft_cmd_arpeggio
0004D7r 2  rr rr        	.word ft_cmd_vibrato
0004D9r 2  rr rr        	.word ft_cmd_tremolo
0004DBr 2  rr rr        	.word ft_cmd_pitch
0004DDr 2  rr rr        	.word ft_cmd_delay
0004DFr 2  rr rr        	.word ft_cmd_dac
0004E1r 2  rr rr        	.word ft_cmd_duty
0004E3r 2  rr rr        	.word ft_cmd_sample_offset
0004E5r 2  rr rr        	.word ft_cmd_slide_up
0004E7r 2  rr rr        	.word ft_cmd_slide_down
0004E9r 2  rr rr        	.word ft_cmd_vol_slide
0004EBr 2  rr rr        	.word ft_cmd_note_cut
0004EDr 2  rr rr        	.word ft_cmd_retrigger
0004EFr 2  rr rr        	.word ft_cmd_dpcm_pitch
0004F1r 2  rr rr        	.word ft_cmd_duration
0004F3r 2  rr rr        	.word ft_cmd_noduration
0004F5r 2               .ifdef USE_FDS
0004F5r 2               	.word ft_cmd_fds_mod_depth
0004F5r 2               	.word ft_cmd_fds_mod_rate_hi
0004F5r 2               	.word ft_cmd_fds_mod_rate_lo
0004F5r 2               .endif
0004F5r 2               .ifdef USE_VRC7
0004F5r 2                   .word ft_cmd_vrc7_patch_change
0004F5r 2               .endif
0004F5r 2               ;	.word ft_cmd_expand
0004F5r 2               
0004F5r 2               ;
0004F5r 2               ; Command functions
0004F5r 2               ;
0004F5r 2               
0004F5r 2               .if 0
0004F5r 2               ; Loop expansion
0004F5r 2               ft_cmd_expand:
0004F5r 2               	lda var_ch_LoopCounter, x	; See if already looping
0004F5r 2               	bne :+
0004F5r 2               	; Load new loop
0004F5r 2               	jsr ft_get_pattern_byte		; number of loops
0004F5r 2               	sta var_ch_LoopCounter, x
0004F5r 2               	jsr ft_get_pattern_byte		; length in bytes
0004F5r 2               	sta var_Temp
0004F5r 2               	; Calculate pattern pointer
0004F5r 2               	sec
0004F5r 2               	lda var_Temp_Pattern
0004F5r 2               	sbc var_Temp
0004F5r 2               	sta var_Temp_Pattern
0004F5r 2               	lda var_Temp_Pattern + 1
0004F5r 2               	sbc #$00
0004F5r 2               	sta var_Temp_Pattern + 1
0004F5r 2               	ldy #$00
0004F5r 2               	jmp ft_read_note
0004F5r 2               :	; Already looping
0004F5r 2               	sec
0004F5r 2               	sbc #$01
0004F5r 2               	beq :+						; Check if done
0004F5r 2               	sta var_ch_LoopCounter, x
0004F5r 2               	iny							; number of loops, ignore
0004F5r 2               	jsr ft_get_pattern_byte		; length in bytes
0004F5r 2               	sta var_Temp
0004F5r 2               	; Calculate pattern pointer
0004F5r 2               	sec
0004F5r 2               	lda var_Temp_Pattern
0004F5r 2               	sbc var_Temp
0004F5r 2               	sta var_Temp_Pattern
0004F5r 2               	lda var_Temp_Pattern + 1
0004F5r 2               	sbc #$00
0004F5r 2               	sta var_Temp_Pattern + 1
0004F5r 2               	ldy #$00
0004F5r 2               	jmp ft_read_note
0004F5r 2               :	; Loop is done
0004F5r 2               	sta var_ch_LoopCounter, x
0004F5r 2               	iny							; number of loops, ignore
0004F5r 2               	iny							; length in bytes, ignore
0004F5r 2               	jmp ft_read_note
0004F5r 2               .endif
0004F5r 2               
0004F5r 2               ; Change instrument
0004F5r 2               ft_cmd_instrument:
0004F5r 2  20 rr rr     	jsr ft_get_pattern_byte
0004F8r 2  20 rr rr     	jsr ft_load_instrument
0004FBr 2  4C rr rr     	jmp ft_read_note
0004FEr 2               ; Effect: Speed (Fxx)
0004FEr 2               ft_cmd_speed:
0004FEr 2  20 rr rr     	jsr ft_get_pattern_byte
000501r 2  C9 15        	cmp #21
000503r 2  90 05        	bcc @SpeedIsTempo
000505r 2  8D rr rr     	sta var_Tempo
000508r 2  B0 03        	bcs @StoreDone
00050Ar 2               @SpeedIsTempo:
00050Ar 2  8D rr rr     	sta var_Speed
00050Dr 2               @StoreDone:
00050Dr 2  20 rr rr     	jsr ft_calculate_speed
000510r 2  4C rr rr     	jmp ft_read_note
000513r 2               ; Effect: Jump (Bxx)
000513r 2               ft_cmd_jump:
000513r 2  20 rr rr     	jsr ft_get_pattern_byte
000516r 2  8D rr rr     	sta var_Jump
000519r 2  4C rr rr     	jmp ft_read_note
00051Cr 2               ; Effect: Skip (Dxx)
00051Cr 2               ft_cmd_skip:
00051Cr 2  20 rr rr     	jsr ft_get_pattern_byte
00051Fr 2  8D rr rr     	sta var_Skip
000522r 2  4C rr rr     	jmp ft_read_note
000525r 2               ; Effect: Halt (Cxx)
000525r 2               ft_cmd_halt:
000525r 2  20 rr rr     	jsr ft_get_pattern_byte
000528r 2  A9 00        	lda #$00
00052Ar 2  8D rr rr     	sta var_PlayerFlags
00052Dr 2  4C rr rr     	jmp ft_read_note
000530r 2               ; Effect: Volume (Exx)
000530r 2               ft_cmd_effvolume:
000530r 2  20 rr rr     	jsr ft_get_pattern_byte
000533r 2  8D rr rr     	sta var_VolTemp
000536r 2  9D rr rr     	sta var_ch_Volume, x
000539r 2  4C rr rr     	jmp ft_read_note
00053Cr 2               ; Effect: Portamento (3xx)
00053Cr 2               ft_cmd_portamento:
00053Cr 2  20 rr rr     	jsr ft_get_pattern_byte
00053Fr 2  9D rr rr     	sta var_ch_EffParam, x
000542r 2  F0 38        	beq ResetEffect
000544r 2  A9 02        	lda #EFF_PORTAMENTO
000546r 2  9D rr rr     	sta var_ch_Effect, x
000549r 2  4C rr rr     	jmp ft_read_note
00054Cr 2               ; Effect: Portamento up (1xx)
00054Cr 2               ft_cmd_porta_up:
00054Cr 2  20 rr rr     	jsr ft_get_pattern_byte
00054Fr 2  9D rr rr     	sta var_ch_EffParam, x
000552r 2  F0 28        	beq ResetEffect
000554r 2  A9 03        	lda #EFF_PORTA_UP
000556r 2               .ifdef USE_FDS
000556r 2               	cpx #FDS_CHANNEL
000556r 2               	bne :+
000556r 2               	lda #EFF_PORTA_DOWN
000556r 2               :
000556r 2               .endif
000556r 2               .ifdef USE_VRC7
000556r 2                  	cpx	#VRC7_CHANNEL
000556r 2               	bcc :+
000556r 2               	lda #EFF_PORTA_DOWN
000556r 2               	:
000556r 2               .endif
000556r 2  9D rr rr     	sta var_ch_Effect, x
000559r 2  4C rr rr     	jmp ft_read_note
00055Cr 2               ; Effect: Portamento down (2xx)
00055Cr 2               ft_cmd_porta_down:
00055Cr 2  20 rr rr     	jsr ft_get_pattern_byte
00055Fr 2  9D rr rr     	sta var_ch_EffParam, x
000562r 2  F0 18        	beq ResetEffect
000564r 2  A9 04        	lda #EFF_PORTA_DOWN
000566r 2               .ifdef USE_FDS
000566r 2               	cpx #FDS_CHANNEL
000566r 2               	bne :+
000566r 2               	lda #EFF_PORTA_UP
000566r 2               :
000566r 2               .endif
000566r 2               .ifdef USE_VRC7
000566r 2                  	cpx	#VRC7_CHANNEL
000566r 2               	bcc :+
000566r 2               	lda #EFF_PORTA_UP
000566r 2               	:
000566r 2               .endif
000566r 2  9D rr rr     	sta var_ch_Effect, x
000569r 2  4C rr rr     	jmp ft_read_note
00056Cr 2               ; Effect: Arpeggio (0xy)
00056Cr 2               ft_cmd_arpeggio:
00056Cr 2  20 rr rr     	jsr ft_get_pattern_byte
00056Fr 2  9D rr rr     	sta var_ch_EffParam, x
000572r 2  F0 08        	beq ResetEffect
000574r 2  A9 01        	lda #EFF_ARPEGGIO
000576r 2  9D rr rr     	sta var_ch_Effect, x
000579r 2  4C rr rr     	jmp ft_read_note
00057Cr 2               ResetEffect:					; Shared by 0, 1, 2, 3
00057Cr 2  9D rr rr     	sta var_ch_Effect, x
00057Fr 2  9D rr rr     	sta var_ch_PortaToLo, x
000582r 2  9D rr rr     	sta var_ch_PortaToHi, x
000585r 2  4C rr rr     	jmp ft_read_note
000588r 2               ; Effect: Hardware sweep (Hxy / Ixy)
000588r 2               ft_cmd_sweep:
000588r 2  20 rr rr     	jsr ft_get_pattern_byte
00058Br 2  8D rr rr     	sta var_Sweep
00058Er 2  4C rr rr     	jmp ft_read_note
000591r 2               ; Effect: Vibrato (4xy)
000591r 2               ft_cmd_vibrato:
000591r 2  20 rr rr     	jsr ft_get_pattern_byte
000594r 2  48           	pha
000595r 2               
000595r 2  BD rr rr     	lda var_ch_VibratoSpeed, x
000598r 2  D0 0C        	bne :++
00059Ar 2               	;lda var_VibratoOffset
00059Ar 2  AD rr rr     	lda var_SongFlags
00059Dr 2  29 02        	and #$02
00059Fr 2  F0 02        	beq :+
0005A1r 2  A9 30        	lda #48
0005A3r 2               :
0005A3r 2  9D rr rr     	sta var_ch_VibratoPos, x
0005A6r 2  68           :	pla
0005A7r 2               
0005A7r 2  48           	pha
0005A8r 2  29 F0        	and #$F0
0005AAr 2  9D rr rr     	sta var_ch_VibratoDepth, x
0005ADr 2  68           	pla
0005AEr 2  29 0F        	and #$0F
0005B0r 2  9D rr rr     	sta var_ch_VibratoSpeed, x
0005B3r 2               ;	cmp #$00
0005B3r 2               ;	beq @ResetVibrato
0005B3r 2  4C rr rr     	jmp ft_read_note
0005B6r 2               ;@ResetVibrato:					; Clear vibrato
0005B6r 2               ;	lda var_VibratoOffset
0005B6r 2               ;	sta var_ch_VibratoPos, x
0005B6r 2               ;	jmp ft_read_note
0005B6r 2               ; Effect: Tremolo (7xy)
0005B6r 2               ft_cmd_tremolo:
0005B6r 2  20 rr rr     	jsr ft_get_pattern_byte
0005B9r 2  48           	pha
0005BAr 2  29 F0        	and #$F0
0005BCr 2  9D rr rr     	sta var_ch_TremoloDepth, x
0005BFr 2  68           	pla
0005C0r 2  29 0F        	and #$0F
0005C2r 2  9D rr rr     	sta var_ch_TremoloSpeed, x
0005C5r 2  C9 00        	cmp #$00
0005C7r 2  F0 03        	beq @ResetTremolo
0005C9r 2  4C rr rr     	jmp ft_read_note
0005CCr 2               @ResetTremolo:					; Clear tremolo
0005CCr 2  9D rr rr     	sta var_ch_TremoloPos, x
0005CFr 2  4C rr rr     	jmp ft_read_note
0005D2r 2               ; Effect: Pitch (Pxx)
0005D2r 2               ft_cmd_pitch:
0005D2r 2  20 rr rr     	jsr ft_get_pattern_byte
0005D5r 2  9D rr rr     	sta var_ch_FinePitch, x
0005D8r 2  4C rr rr     	jmp ft_read_note
0005DBr 2               ; Effect: Delay (Gxx)
0005DBr 2               ft_cmd_delay:
0005DBr 2  20 rr rr     	jsr ft_get_pattern_byte
0005DEr 2  9D rr rr     	sta var_ch_Delay, x
0005E1r 2  88           	dey
0005E2r 2  4C rr rr     	jmp ft_read_is_done
0005E5r 2               ; Effect: delta counter setting (Zxx)
0005E5r 2               ft_cmd_dac:
0005E5r 2  20 rr rr     	jsr ft_get_pattern_byte
0005E8r 2               .ifdef USE_DPCM
0005E8r 2  8D rr rr     	sta var_ch_DPCMDAC
0005EBr 2               .endif
0005EBr 2  4C rr rr     	jmp ft_read_note
0005EEr 2               ; Effect: Duty cycle (Vxx)
0005EEr 2               ft_cmd_duty:
0005EEr 2  20 rr rr     	jsr ft_get_pattern_byte
0005F1r 2  9D rr rr     	sta var_ch_DutyCycle, x	; xxxxyyyy: xxxx = default value, yyyy = current value
0005F4r 2  18           	clc
0005F5r 2  0A           	asl a
0005F6r 2  0A           	asl a
0005F7r 2  0A           	asl a
0005F8r 2  0A           	asl a
0005F9r 2  1D rr rr     	ora var_ch_DutyCycle, x
0005FCr 2  9D rr rr     	sta var_ch_DutyCycle, x
0005FFr 2  4C rr rr     	jmp ft_read_note
000602r 2               ; Effect: Sample offset
000602r 2               ft_cmd_sample_offset:
000602r 2  20 rr rr     	jsr ft_get_pattern_byte
000605r 2               .ifdef USE_DPCM
000605r 2  8D rr rr     	sta var_ch_DPCM_Offset
000608r 2               .endif
000608r 2  4C rr rr     	jmp ft_read_note
00060Br 2               ; Effect: Slide pitch up
00060Br 2               ft_cmd_slide_up:
00060Br 2  20 rr rr     	jsr ft_get_pattern_byte			; Fetch speed / note
00060Er 2  9D rr rr     	sta var_ch_EffParam, x
000611r 2  A9 05        	lda #EFF_SLIDE_UP_LOAD
000613r 2  9D rr rr     	sta var_ch_Effect, x
000616r 2  4C rr rr     	jmp ft_read_note
000619r 2               ; Effect: Slide pitch down
000619r 2               ft_cmd_slide_down:
000619r 2  20 rr rr     	jsr ft_get_pattern_byte			; Fetch speed / note
00061Cr 2  9D rr rr     	sta var_ch_EffParam, x
00061Fr 2  A9 07        	lda #EFF_SLIDE_DOWN_LOAD
000621r 2  9D rr rr     	sta var_ch_Effect, x
000624r 2  4C rr rr     	jmp ft_read_note
000627r 2               ; Effect: Volume slide
000627r 2               ft_cmd_vol_slide:
000627r 2  20 rr rr     	jsr ft_get_pattern_byte			; Fetch speed / note
00062Ar 2  9D rr rr     	sta var_ch_VolSlide, x
00062Dr 2  4C rr rr     	jmp ft_read_note
000630r 2               ; Effect: Note cut (Sxx)
000630r 2               ft_cmd_note_cut:
000630r 2  20 rr rr     	jsr ft_get_pattern_byte
000633r 2  09 80        	ora #$80
000635r 2  9D rr rr     	sta var_ch_NoteCut, x
000638r 2  4C rr rr     	jmp ft_read_note
00063Br 2               ; Effect: Retrigger
00063Br 2               ft_cmd_retrigger:
00063Br 2  20 rr rr     	jsr ft_get_pattern_byte
00063Er 2               .ifdef USE_DPCM
00063Er 2  8D rr rr     	sta var_ch_DPCM_Retrig
000641r 2  AD rr rr     	lda var_ch_DPCM_RetrigCntr
000644r 2  D0 06        	bne :+
000646r 2  AD rr rr     	lda var_ch_DPCM_Retrig
000649r 2  8D rr rr     	sta var_ch_DPCM_RetrigCntr
00064Cr 2               .endif
00064Cr 2  4C rr rr     :	jmp ft_read_note
00064Fr 2               ; Effect: DPCM pitch setting
00064Fr 2               ft_cmd_dpcm_pitch:
00064Fr 2  20 rr rr         jsr ft_get_pattern_byte
000652r 2  8D rr rr         sta var_ch_DPCM_EffPitch
000655r 2  4C rr rr     	jmp ft_read_note
000658r 2               ; End of effect column commands
000658r 2               ; Set default note duration
000658r 2               ft_cmd_duration:
000658r 2  20 rr rr     	jsr ft_get_pattern_byte
00065Br 2  9D rr rr     	sta var_ch_DefaultDelay, x
00065Er 2  4C rr rr     	jmp ft_read_note
000661r 2               ; No default note duration
000661r 2               ft_cmd_noduration:
000661r 2  A9 FF        	lda #$FF
000663r 2  9D rr rr     	sta var_ch_DefaultDelay, x
000666r 2  4C rr rr     	jmp ft_read_note
000669r 2               ; FDS
000669r 2               
000669r 2               .ifdef USE_FDS
000669r 2               
000669r 2               ft_cmd_fds_mod_depth:
000669r 2               	jsr ft_get_pattern_byte
000669r 2               	sta var_ch_ModEffDepth
000669r 2               	lda var_ch_ModEffWritten
000669r 2               	ora #$01
000669r 2               	sta var_ch_ModEffWritten
000669r 2               	jmp ft_read_note
000669r 2               ft_cmd_fds_mod_rate_hi:
000669r 2               	jsr ft_get_pattern_byte
000669r 2               	sta var_ch_ModEffRateHi
000669r 2               	lda var_ch_ModEffWritten
000669r 2               	ora #$02
000669r 2               	sta var_ch_ModEffWritten
000669r 2               	jmp ft_read_note
000669r 2               ft_cmd_fds_mod_rate_lo:
000669r 2               	jsr ft_get_pattern_byte
000669r 2               	sta var_ch_ModEffRateLo
000669r 2               	lda var_ch_ModEffWritten
000669r 2               	ora #$04
000669r 2               	sta var_ch_ModEffWritten
000669r 2               	jmp ft_read_note
000669r 2               
000669r 2               .endif
000669r 2               
000669r 2               ; VRC7
000669r 2               .ifdef USE_VRC7
000669r 2               ft_cmd_vrc7_patch_change:
000669r 2               	jsr ft_get_pattern_byte
000669r 2               	sta var_ch_vrc7_EffPatch
000669r 2               	sta var_ch_vrc7_Patch - VRC7_CHANNEL, x
000669r 2               	jmp ft_read_note
000669r 2               .endif
000669r 2               
000669r 2               ;
000669r 2               ; End of commands
000669r 2               ;
000669r 2               
000669r 2               .ifdef USE_VRC6
000669r 2               ft_load_vrc6_saw_table:
000669r 2               	cpx #SAW_CHANNEL
000669r 2               	bne :+
000669r 2               	pha						; Load VRC6 sawtooth table
000669r 2               	lda #<ft_periods_sawtooth
000669r 2               	sta var_Note_Table
000669r 2               	lda #>ft_periods_sawtooth
000669r 2               	sta var_Note_Table + 1
000669r 2               	pla
000669r 2               	rts
000669r 2               :	pha						; Load 2A03 table
000669r 2               	lda #<ft_notes_ntsc
000669r 2               	sta var_Note_Table
000669r 2               	lda #>ft_notes_ntsc
000669r 2               	sta var_Note_Table + 1
000669r 2               	pla
000669r 2               	rts
000669r 2               .endif
000669r 2               
000669r 2               .ifdef USE_FDS
000669r 2               ft_load_fds_table:
000669r 2               	cpx #FDS_CHANNEL
000669r 2               	bne :+
000669r 2               	pha
000669r 2               	lda #<ft_periods_fds		; Load FDS table
000669r 2               	sta var_Note_Table
000669r 2               	lda #>ft_periods_fds
000669r 2               	sta var_Note_Table + 1
000669r 2               	pla
000669r 2               	rts
000669r 2               :	pha
000669r 2               	lda	#<ft_notes_ntsc			; Load 2A03 table
000669r 2               	sta var_Note_Table
000669r 2               	lda #>ft_notes_ntsc
000669r 2               	sta var_Note_Table + 1
000669r 2               	pla
000669r 2               	rts
000669r 2               .endif
000669r 2               
000669r 2               ft_translate_freq_only:
000669r 2               
000669r 2  38           	sec
00066Ar 2  E9 01        	sbc #$01
00066Cr 2               
00066Cr 2               .ifdef USE_VRC7
00066Cr 2               	cpx	#VRC7_CHANNEL
00066Cr 2               	bcc :+
00066Cr 2               	sta var_ch_vrc7_ActiveNote - VRC7_CHANNEL, x
00066Cr 2               	jsr ft_vrc7_get_freq_only
00066Cr 2               	rts
00066Cr 2               :
00066Cr 2               .endif
00066Cr 2               
00066Cr 2               
00066Cr 2  E0 03        	cpx #NOISE_CHANNEL							; Check if noise
00066Er 2  F0 12        	beq StoreNoise2
000670r 2               
000670r 2               .ifdef USE_VRC6
000670r 2               	jsr	ft_load_vrc6_saw_table
000670r 2               .endif
000670r 2               .ifdef USE_FDS
000670r 2               	jsr ft_load_fds_table
000670r 2               .endif
000670r 2               
000670r 2  0A           	asl a
000671r 2  84 rr        	sty var_Temp
000673r 2  A8           	tay
000674r 2               LoadFrequency:
000674r 2  B1 rr        	lda (var_Note_Table), y
000676r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000679r 2  C8           	iny
00067Ar 2  B1 rr        	lda (var_Note_Table), y
00067Cr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
00067Fr 2  A4 rr        	ldy var_Temp
000681r 2  60           	rts
000682r 2               
000682r 2               StoreNoise2:
000682r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000685r 2  A9 00        	lda #$00
000687r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
00068Ar 2  60               rts
00068Br 2               
00068Br 2               ; Translate the note in A to a frequency and stores in current channel
00068Br 2               ; If portamento is enabled, store in PortaTo
00068Br 2               ft_translate_freq:
00068Br 2               
00068Br 2  38           	sec
00068Cr 2  E9 01        	sbc #$01
00068Er 2               
00068Er 2               .ifdef USE_DPCM
00068Er 2  E0 04        	cpx #DPCM_CHANNEL				; Check if DPCM
000690r 2  F0 65        	beq StoreDPCM
000692r 2               .endif
000692r 2               
000692r 2               .ifdef USE_VRC7
000692r 2               	cpx #VRC7_CHANNEL
000692r 2               	bcc :+
000692r 2               ;	clc
000692r 2               ;	adc #$01						; todo: remove this eventually
000692r 2               	sta var_ch_vrc7_ActiveNote - VRC7_CHANNEL, x
000692r 2               	jsr ft_vrc7_get_freq
000692r 2               	rts
000692r 2               :
000692r 2               .endif
000692r 2               
000692r 2  E0 03        	cpx #NOISE_CHANNEL				; Check if noise
000694r 2  F0 31        	beq StoreNoise
000696r 2               
000696r 2               .ifdef USE_VRC6
000696r 2               	jsr	ft_load_vrc6_saw_table
000696r 2               .endif
000696r 2               .ifdef USE_FDS
000696r 2               	jsr ft_load_fds_table
000696r 2               .endif
000696r 2               
000696r 2  0A           	asl a
000697r 2  84 rr        	sty var_Temp
000699r 2  A8           	tay
00069Ar 2               	; Check portamento
00069Ar 2               	;lda var_ch_PortaSpeed, x
00069Ar 2  BD rr rr     	lda var_ch_Effect, x
00069Dr 2  C9 02        	cmp #EFF_PORTAMENTO
00069Fr 2  D0 22        	bne @NoPorta
0006A1r 2               	; Load portamento
0006A1r 2  B1 rr        	lda (var_Note_Table), y
0006A3r 2  9D rr rr     	sta var_ch_PortaToLo, x
0006A6r 2  C8           	iny
0006A7r 2  B1 rr        	lda (var_Note_Table), y
0006A9r 2  9D rr rr     	sta var_ch_PortaToHi, x
0006ACr 2  A4 rr        	ldy var_Temp
0006AEr 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
0006B1r 2  1D rr rr     	ora var_ch_TimerPeriodHi, x
0006B4r 2  D0 0C        	bne @Return
0006B6r 2  BD rr rr     	lda var_ch_PortaToLo, x
0006B9r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
0006BCr 2  BD rr rr     	lda var_ch_PortaToHi, x
0006BFr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
0006C2r 2               @Return:
0006C2r 2  60           	rts
0006C3r 2               @NoPorta:
0006C3r 2  4C rr rr     	jmp LoadFrequency
0006C6r 2  60           	rts
0006C7r 2               StoreNoise:							; Special case for noise
0006C7r 2               
0006C7r 2  48               pha
0006C8r 2  BD rr rr     	lda var_ch_Effect, x
0006CBr 2  C9 02        	cmp #EFF_PORTAMENTO
0006CDr 2  D0 1E        	bne @NoPorta
0006CFr 2  68           	pla
0006D0r 2  9D rr rr     	sta var_ch_PortaToLo, x
0006D3r 2  A9 00        	lda #$00
0006D5r 2  9D rr rr     	sta var_ch_PortaToHi, x
0006D8r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
0006DBr 2  1D rr rr     	ora var_ch_TimerPeriodHi, x
0006DEr 2  D0 0C        	bne @Return
0006E0r 2  BD rr rr     	lda var_ch_PortaToLo, x
0006E3r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
0006E6r 2  BD rr rr     	lda var_ch_PortaToHi, x
0006E9r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
0006ECr 2               @Return:
0006ECr 2  60           	rts
0006EDr 2               @NoPorta:
0006EDr 2  68               pla
0006EEr 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
0006F1r 2  A9 00        	lda #$00
0006F3r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
0006F6r 2  60           	rts
0006F7r 2               
0006F7r 2               .ifdef USE_DPCM
0006F7r 2               StoreDPCM:							; Special case for DPCM
0006F7r 2               
0006F7r 2  48           	pha
0006F8r 2  AD rr rr     	lda var_dpcm_inst_list			; Optimize this maybe?
0006FBr 2  85 rr        	sta var_Temp16
0006FDr 2  AD rr rr     	lda var_dpcm_inst_list + 1
000700r 2  85 rr        	sta var_Temp16 + 1
000702r 2  68           	pla
000703r 2               
000703r 2  84 rr        	sty var_Temp
000705r 2  A8           	tay
000706r 2  B1 rr        	lda (var_Temp16), y				; Read pitch
000708r 2  8D rr rr     	sta var_ch_SamplePitch
00070Br 2  C8           	iny
00070Cr 2  B1 rr        	lda (var_Temp16), y				; Read sample
00070Er 2  A8           	tay
00070Fr 2               
00070Fr 2  AD rr rr     	lda var_dpcm_pointers			; Load sample pointer list
000712r 2  85 rr        	sta var_Temp16
000714r 2  AD rr rr     	lda var_dpcm_pointers + 1
000717r 2  85 rr        	sta var_Temp16 + 1
000719r 2               
000719r 2  B1 rr        	lda (var_Temp16), y				; Get sample position
00071Br 2  8D rr rr     	sta var_ch_SamplePtr
00071Er 2  C8           	iny
00071Fr 2  B1 rr        	lda (var_Temp16), y				; And size
000721r 2  8D rr rr     	sta var_ch_SampleLen
000724r 2               
000724r 2  A4 rr        	ldy var_Temp
000726r 2  60           	rts
000727r 2               .endif
000727r 2               
000727r 2               ; Reload speed division counter
000727r 2               ft_restore_speed:
000727r 2  18           	clc
000728r 2  AD rr rr     	lda var_Tempo_Accum
00072Br 2  6D rr rr     	adc var_Tempo_Dec
00072Er 2  8D rr rr     	sta var_Tempo_Accum
000731r 2  AD rr rr     	lda var_Tempo_Accum + 1
000734r 2  6D rr rr     	adc var_Tempo_Dec + 1
000737r 2  8D rr rr     	sta var_Tempo_Accum + 1
00073Ar 2  60           	rts
00073Br 2               
00073Br 2               ; Calculate frame division from the speed and tempo settings
00073Br 2               ft_calculate_speed:
00073Br 2  98           	tya
00073Cr 2  48           	pha
00073Dr 2               
00073Dr 2               	; Multiply by 24
00073Dr 2  AD rr rr     	lda var_Tempo
000740r 2  85 rr        	sta AUX
000742r 2  A9 00        	lda #$00
000744r 2  85 rr        	sta AUX + 1
000746r 2  A0 03        	ldy #$03
000748r 2               @rotate:
000748r 2  06 rr        	asl AUX
00074Ar 2  26 rr        	rol AUX	+ 1
00074Cr 2  88           	dey
00074Dr 2  D0 F9        	bne @rotate
00074Fr 2  A5 rr        	lda AUX
000751r 2  85 rr        	sta ACC
000753r 2  A5 rr        	lda AUX + 1
000755r 2  A8           	tay
000756r 2  06 rr        	asl AUX
000758r 2  26 rr        	rol AUX	+ 1
00075Ar 2  18           	clc
00075Br 2  A5 rr        	lda ACC
00075Dr 2  65 rr        	adc AUX
00075Fr 2  85 rr        	sta ACC
000761r 2  98           	tya
000762r 2  65 rr        	adc AUX + 1
000764r 2  85 rr        	sta ACC + 1
000766r 2               
000766r 2               	; divide by speed
000766r 2  AD rr rr     	lda var_Speed
000769r 2  85 rr        	sta AUX
00076Br 2  A9 00        	lda #$00
00076Dr 2  85 rr        	sta AUX + 1
00076Fr 2  20 rr rr     	jsr DIV		; ACC/AUX -> ACC, remainder in EXT
000772r 2  A5 rr        	lda ACC
000774r 2  8D rr rr     	sta var_Tempo_Count
000777r 2  A5 rr        	lda ACC + 1
000779r 2  8D rr rr     	sta var_Tempo_Count + 1
00077Cr 2  68           	pla
00077Dr 2  A8               tay
00077Er 2               
00077Er 2  60           	rts
00077Fr 2               
00077Fr 2               ; If anyone knows a way to calculate speed without using
00077Fr 2               ; multiplication or division, please contact me
00077Fr 2               
00077Fr 2               ; ACC/AUX -> ACC, remainder in EXT
00077Fr 2  A9 00        DIV:      LDA #0
000781r 2  85 rr                  STA EXT+1
000783r 2  A0 10                  LDY #$10
000785r 2  06 rr        LOOP2:    ASL ACC
000787r 2  26 rr                  ROL ACC+1
000789r 2  2A                     ROL
00078Ar 2  26 rr                  ROL EXT+1
00078Cr 2  48                     PHA
00078Dr 2  C5 rr                  CMP AUX
00078Fr 2  A5 rr                  LDA EXT+1
000791r 2  E5 rr                  SBC AUX+1
000793r 2  90 08                  BCC DIV2
000795r 2  85 rr                  STA EXT+1
000797r 2  68                     PLA
000798r 2  E5 rr                  SBC AUX
00079Ar 2  48                     PHA
00079Br 2  E6 rr                  INC ACC
00079Dr 2  68           DIV2:     PLA
00079Er 2  88                     DEY
00079Fr 2  D0 E4                  BNE LOOP2
0007A1r 2  85 rr                  STA EXT
0007A3r 2  60                     RTS
0007A4r 2               
0007A4r 1               	.include "effects.s"
0007A4r 2               ;
0007A4r 2               ; Update track effects
0007A4r 2               ;
0007A4r 2               ft_run_effects:
0007A4r 2               
0007A4r 2               	; Volume slide
0007A4r 2  BD rr rr     	lda var_ch_VolSlide, x
0007A7r 2  F0 2A        	beq @NoVolSlide
0007A9r 2               	; First calculate volume decrease
0007A9r 2  BD rr rr     	lda var_ch_VolSlide, x
0007ACr 2  29 0F        	and #$0F
0007AEr 2  85 rr        	sta var_Temp
0007B0r 2  38           	sec
0007B1r 2  BD rr rr     	lda var_ch_VolColumn, x
0007B4r 2  E5 rr        	sbc var_Temp
0007B6r 2  10 02        	bpl :+
0007B8r 2  A9 00        	lda #$00
0007BAr 2  9D rr rr     :	sta var_ch_VolColumn, x
0007BDr 2  BD rr rr     	lda var_ch_VolSlide, x
0007C0r 2  4A           	lsr a
0007C1r 2  4A           	lsr a
0007C2r 2  4A           	lsr a
0007C3r 2  4A           	lsr a
0007C4r 2  85 rr        	sta var_Temp
0007C6r 2  18           	clc
0007C7r 2  BD rr rr     	lda var_ch_VolColumn, x
0007CAr 2  65 rr        	adc var_Temp
0007CCr 2  10 02        	bpl :+
0007CEr 2  A9 7F        	lda #$7F
0007D0r 2  9D rr rr     :	sta var_ch_VolColumn, x
0007D3r 2               @NoVolSlide:
0007D3r 2               
0007D3r 2               .if 0
0007D3r 2                   lda var_ch_Effect, x
0007D3r 2                   bne :+
0007D3r 2                   ; No effect
0007D3r 2                   rts
0007D3r 2               :	asl a
0007D3r 2               	tay
0007D3r 2               	lda ft_effect_table - 2, y
0007D3r 2               	sta var_Temp_Pointer
0007D3r 2               	lda ft_effect_table - 1, y
0007D3r 2               	sta var_Temp_Pointer + 1
0007D3r 2               	jmp (var_Temp_Pointer)
0007D3r 2               .endif
0007D3r 2               
0007D3r 2               ;.if 0
0007D3r 2               	; Arpeggio and portamento
0007D3r 2  BD rr rr     	lda var_ch_Effect, x
0007D6r 2  F0 31        	beq @NoEffect
0007D8r 2  C9 01        	cmp #EFF_ARPEGGIO
0007DAr 2  F0 1B        	beq @EffArpeggio
0007DCr 2  C9 02        	cmp #EFF_PORTAMENTO
0007DEr 2  F0 1A        	beq @EffPortamento
0007E0r 2  C9 03        	cmp #EFF_PORTA_UP
0007E2r 2  F0 19        	beq @EffPortaUp
0007E4r 2  C9 06        	cmp #EFF_SLIDE_UP
0007E6r 2  F0 18        	beq @EffSlideUp
0007E8r 2  C9 08        	cmp #EFF_SLIDE_DOWN
0007EAr 2  F0 17        	beq @EffSlideDown
0007ECr 2               
0007ECr 2  C9 05        	cmp #EFF_SLIDE_UP_LOAD
0007EEr 2  F0 16        	beq @EffLoadSlide
0007F0r 2  C9 07        	cmp #EFF_SLIDE_DOWN_LOAD
0007F2r 2  F0 12        	beq @EffLoadSlide
0007F4r 2               
0007F4r 2  4C rr rr     	jmp ft_portamento_down
0007F7r 2               
0007F7r 2               @EffArpeggio:
0007F7r 2  4C rr rr     	jmp ft_arpeggio
0007FAr 2               @EffPortamento:
0007FAr 2  4C rr rr     	jmp ft_portamento
0007FDr 2               @EffPortaUp:
0007FDr 2  4C rr rr     	jmp ft_portamento_up
000800r 2               @EffSlideUp:
000800r 2  4C rr rr     	jmp	ft_slide_up
000803r 2               @EffSlideDown:
000803r 2  4C rr rr     	jmp	ft_slide_down
000806r 2               @EffLoadSlide:
000806r 2  4C rr rr     	jmp ft_load_slide
000809r 2               @NoEffect:
000809r 2               ;.endif
000809r 2               ft_post_effects:
000809r 2  60           	rts
00080Ar 2               
00080Ar 2               ft_effect_table:
00080Ar 2  rr rr rr rr      .word ft_arpeggio, ft_portamento, ft_portamento_up, ft_portamento_down
00080Er 2  rr rr rr rr  
000812r 2  rr rr rr rr      .word ft_load_slide, ft_slide_up, ft_load_slide, ft_slide_down
000816r 2  rr rr rr rr  
00081Ar 2               
00081Ar 2               
00081Ar 2               ft_load_slide:
00081Ar 2               
00081Ar 2               .ifdef USE_VRC7
00081Ar 2               	cpx #VRC7_CHANNEL
00081Ar 2               	bcc :+								; <
00081Ar 2               	cpx #VRC7_CHANNEL + 6
00081Ar 2               	bcs :+								; >
00081Ar 2               	jmp ft_vrc7_load_slide
00081Ar 2               :	; VRC7 skip
00081Ar 2               .endif
00081Ar 2               
00081Ar 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
00081Dr 2  48           	pha
00081Er 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
000821r 2  48           	pha
000822r 2               	; Load note
000822r 2  BD rr rr     	lda var_ch_EffParam, x			; Store speed
000825r 2  29 0F        	and #$0F						; Get note
000827r 2  85 rr        	sta var_Temp					; Store note in temp
000829r 2               
000829r 2  BD rr rr     	lda var_ch_Effect, x
00082Cr 2  C9 05        	cmp #EFF_SLIDE_UP_LOAD
00082Er 2  F0 09        	beq :+
000830r 2  BD rr rr     	lda var_ch_Note, x
000833r 2  38           	sec
000834r 2  E5 rr        	sbc var_Temp
000836r 2  4C rr rr     	jmp :++
000839r 2  BD rr rr     :	lda var_ch_Note, x
00083Cr 2  18           	clc
00083Dr 2  65 rr        	adc var_Temp
00083Fr 2  9D rr rr     :	sta var_ch_Note, x
000842r 2  20 rr rr     	jsr	ft_translate_freq_only
000845r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
000848r 2  9D rr rr     	sta var_ch_PortaToLo, x
00084Br 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
00084Er 2  9D rr rr     	sta var_ch_PortaToHi, x
000851r 2               	; Store speed
000851r 2  BD rr rr     	lda var_ch_EffParam, x
000854r 2  4A           	lsr a
000855r 2  4A           	lsr a
000856r 2  4A           	lsr a
000857r 2  09 01        	ora #$01
000859r 2  9D rr rr     	sta var_ch_EffParam, x
00085Cr 2               	; Load old period
00085Cr 2  68           	pla
00085Dr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000860r 2  68           	pla
000861r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000864r 2               	; change mode to sliding
000864r 2  18           	clc
000865r 2  BD rr rr     	lda var_ch_Effect, x
000868r 2  69 01        	adc #01
00086Ar 2               .ifdef USE_FDS
00086Ar 2               	; FDS's frequency reg is inverted
00086Ar 2               	cpx #FDS_CHANNEL
00086Ar 2               	bne :++
00086Ar 2               	cmp #EFF_SLIDE_UP
00086Ar 2               	bne :+
00086Ar 2               	lda #EFF_SLIDE_DOWN
00086Ar 2               	jmp :++
00086Ar 2               :	lda #EFF_SLIDE_UP
00086Ar 2               :
00086Ar 2               .endif
00086Ar 2  9D rr rr     	sta var_ch_Effect, x
00086Dr 2  60           	rts
00086Er 2               
00086Er 2               ft_calc_freq:
00086Er 2               
00086Er 2                	; Load frequency
00086Er 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
000871r 2  9D rr rr     	sta var_ch_PeriodCalcLo, x
000874r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
000877r 2  9D rr rr     	sta var_ch_PeriodCalcHi, x
00087Ar 2               
00087Ar 2               .ifdef USE_VRC7
00087Ar 2               	cpx #VRC7_CHANNEL
00087Ar 2               	bcc :+
00087Ar 2               	lsr var_ch_PeriodCalcHi, x
00087Ar 2               	ror var_ch_PeriodCalcLo, x
00087Ar 2               	lsr var_ch_PeriodCalcHi, x
00087Ar 2               	ror var_ch_PeriodCalcLo, x
00087Ar 2               :
00087Ar 2               .endif
00087Ar 2               
00087Ar 2               	; Apply fine pitch
00087Ar 2  BD rr rr      	lda var_ch_FinePitch, x
00087Dr 2  C9 80         	cmp #$80
00087Fr 2  F0 23         	beq @Skip
000881r 2  18           	clc
000882r 2  BD rr rr     	lda var_ch_PeriodCalcLo, x
000885r 2  69 80        	adc #$80
000887r 2  9D rr rr     	sta var_ch_PeriodCalcLo, x
00088Ar 2  BD rr rr     	lda var_ch_PeriodCalcHi, x
00088Dr 2  69 00        	adc #$00
00088Fr 2  9D rr rr     	sta var_ch_PeriodCalcHi, x
000892r 2  38           	sec
000893r 2  BD rr rr     	lda var_ch_PeriodCalcLo, x
000896r 2  FD rr rr     	sbc var_ch_FinePitch, x
000899r 2  9D rr rr     	sta var_ch_PeriodCalcLo, x
00089Cr 2  BD rr rr     	lda var_ch_PeriodCalcHi, x
00089Fr 2  E9 00        	sbc #$00
0008A1r 2  9D rr rr     	sta var_ch_PeriodCalcHi, x
0008A4r 2               @Skip:
0008A4r 2               
0008A4r 2  20 rr rr     	jsr ft_vibrato
0008A7r 2  20 rr rr     	jsr ft_tremolo
0008AAr 2               
0008AAr 2  60           	rts
0008ABr 2               
0008ABr 2               
0008ABr 2               ;
0008ABr 2               ; Portamento
0008ABr 2               ;
0008ABr 2               ft_portamento:
0008ABr 2  BD rr rr     	lda var_ch_EffParam, x						; Check portamento, if speed > 0
0008AEr 2  F0 7B        	beq @NoPortamento
0008B0r 2  BD rr rr     	lda var_ch_PortaToLo, x						; and if freq > 0, else stop
0008B3r 2  1D rr rr     	ora var_ch_PortaToHi, x
0008B6r 2  F0 73        	beq @NoPortamento
0008B8r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x		; Compare high byte
0008BBr 2  DD rr rr     	cmp var_ch_PortaToHi, x
0008BEr 2  90 38        	bcc @Increase
0008C0r 2  D0 0D        	bne @Decrease
0008C2r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x						; Compare low byte
0008C5r 2  DD rr rr     	cmp var_ch_PortaToLo, x
0008C8r 2  90 2E        	bcc @Increase
0008CAr 2  D0 03        	bne @Decrease
0008CCr 2               	;rts											; done
0008CCr 2  4C rr rr     	jmp ft_post_effects
0008CFr 2               @Decrease:											; Decrease frequency
0008CFr 2  38           	sec
0008D0r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
0008D3r 2  FD rr rr     	sbc var_ch_EffParam, x
0008D6r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
0008D9r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
0008DCr 2  E9 00        	sbc #$00
0008DEr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
0008E1r 2               	; Check if sign bit has changed, if so load the desired frequency
0008E1r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x			; Compare high byte
0008E4r 2  DD rr rr     	cmp var_ch_PortaToHi, x
0008E7r 2  90 36        	bcc @LoadFrequency
0008E9r 2  30 34        	bmi @LoadFrequency
0008EBr 2  D0 3E        	bne @NoPortamento
0008EDr 2  BD rr rr     	lda var_ch_TimerPeriodLo, x						; Compare low byte
0008F0r 2  DD rr rr     	cmp var_ch_PortaToLo, x
0008F3r 2  90 2A        	bcc @LoadFrequency
0008F5r 2               ;	rts												; Portamento is done at this point
0008F5r 2  4C rr rr     	jmp ft_post_effects
0008F8r 2               
0008F8r 2               @Increase:											; Increase frequency
0008F8r 2  18           	clc
0008F9r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
0008FCr 2  7D rr rr     	adc var_ch_EffParam, x
0008FFr 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000902r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
000905r 2  69 00        	adc #$00
000907r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
00090Ar 2               	; Check if sign bit has changed, if so load the desired frequency
00090Ar 2  BD rr rr     	lda var_ch_PortaToHi, x							; Compare high byte
00090Dr 2  DD rr rr     	cmp var_ch_TimerPeriodHi, x
000910r 2  90 0D        	bcc @LoadFrequency
000912r 2  D0 17        	bne @NoPortamento
000914r 2  BD rr rr     	lda var_ch_PortaToLo, x							; Compare low byte
000917r 2  DD rr rr     	cmp var_ch_TimerPeriodLo, x
00091Ar 2  90 03        	bcc @LoadFrequency
00091Cr 2               ;	rts
00091Cr 2  4C rr rr     	jmp ft_post_effects
00091Fr 2               
00091Fr 2               @LoadFrequency:										; Load the correct frequency
00091Fr 2  BD rr rr     	lda var_ch_PortaToLo, x
000922r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000925r 2  BD rr rr     	lda var_ch_PortaToHi, x
000928r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
00092Br 2               @NoPortamento:
00092Br 2  4C rr rr     	jmp ft_post_effects
00092Er 2               
00092Er 2               ft_portamento_up:
00092Er 2  38           	sec
00092Fr 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
000932r 2  FD rr rr     	sbc var_ch_EffParam, x
000935r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000938r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
00093Br 2  E9 00        	sbc #$00
00093Dr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000940r 2  20 rr rr     	jsr ft_limit_freq
000943r 2  4C rr rr     	jmp ft_post_effects
000946r 2               ft_portamento_down:
000946r 2  18           	clc
000947r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
00094Ar 2  7D rr rr     	adc var_ch_EffParam, x
00094Dr 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000950r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
000953r 2  69 00        	adc #$00
000955r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000958r 2  20 rr rr     	jsr ft_limit_freq
00095Br 2  4C rr rr     	jmp ft_post_effects
00095Er 2               
00095Er 2               ;
00095Er 2               ; Note slide
00095Er 2               ;
00095Er 2               ft_slide_up:
00095Er 2  38           	sec
00095Fr 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
000962r 2  FD rr rr     	sbc var_ch_EffParam, x
000965r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000968r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
00096Br 2  E9 00        	sbc #$00
00096Dr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000970r 2  DD rr rr     	cmp var_ch_PortaToHi, x			; Compare high byte
000973r 2  90 31        	bcc ft_slide_done
000975r 2  D0 40        	bne ft_slide_not_done
000977r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
00097Ar 2  DD rr rr     	cmp var_ch_PortaToLo, x						; Compare low byte
00097Dr 2  90 27        	bcc ft_slide_done
00097Fr 2  4C rr rr     	jmp ft_post_effects
000982r 2               ft_slide_down:
000982r 2  18           	clc
000983r 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
000986r 2  7D rr rr     	adc var_ch_EffParam, x
000989r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
00098Cr 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
00098Fr 2  69 00        	adc #$00
000991r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000994r 2  DD rr rr     	cmp var_ch_PortaToHi, x			; Compare high byte
000997r 2  90 1E        	bcc ft_slide_not_done
000999r 2  D0 0B        	bne ft_slide_done
00099Br 2  BD rr rr     	lda var_ch_TimerPeriodLo, x
00099Er 2  DD rr rr     	cmp var_ch_PortaToLo, x						; Compare low byte
0009A1r 2  B0 03        	bcs ft_slide_done
0009A3r 2  4C rr rr     	jmp ft_post_effects
0009A6r 2               ft_slide_done:
0009A6r 2  BD rr rr     	lda var_ch_PortaToLo, x
0009A9r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
0009ACr 2  BD rr rr     	lda var_ch_PortaToHi, x
0009AFr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
0009B2r 2  A9 00        	lda #EFF_NONE								; Reset effect
0009B4r 2  9D rr rr     	sta var_ch_Effect, x
0009B7r 2               ft_slide_not_done:
0009B7r 2  4C rr rr     	jmp ft_post_effects
0009BAr 2               
0009BAr 2               ;
0009BAr 2               ; Arpeggio
0009BAr 2               ;
0009BAr 2               ft_arpeggio:
0009BAr 2  BD rr rr     	lda var_ch_ArpeggioCycle, x
0009BDr 2  C9 01        	cmp #$01
0009BFr 2  F0 10        	beq @LoadSecond
0009C1r 2  C9 02        	cmp #$02
0009C3r 2  F0 2D        	beq @LoadThird
0009C5r 2  BD rr rr     	lda var_ch_Note, x							; Load first note
0009C8r 2  20 rr rr     	jsr ft_translate_freq_only
0009CBr 2  FE rr rr     	inc var_ch_ArpeggioCycle, x
0009CEr 2  4C rr rr     	jmp ft_post_effects
0009D1r 2               @LoadSecond:									; Second note (second nybble)
0009D1r 2  BD rr rr     	lda var_ch_EffParam, x
0009D4r 2  4A           	lsr a
0009D5r 2  4A           	lsr a
0009D6r 2  4A           	lsr a
0009D7r 2  4A           	lsr a
0009D8r 2  18           	clc
0009D9r 2  7D rr rr     	adc var_ch_Note, x
0009DCr 2  20 rr rr     	jsr ft_translate_freq_only
0009DFr 2  BD rr rr     	lda var_ch_EffParam, x						; see if cycle should reset here
0009E2r 2  29 0F        	and #$0F
0009E4r 2  D0 06        	bne @DoNextStep
0009E6r 2  9D rr rr     	sta var_ch_ArpeggioCycle, x
0009E9r 2  4C rr rr     	jmp ft_post_effects
0009ECr 2               @DoNextStep:
0009ECr 2  FE rr rr     	inc var_ch_ArpeggioCycle, x
0009EFr 2  4C rr rr     	jmp ft_post_effects
0009F2r 2               @LoadThird:										; Third note (first nybble)
0009F2r 2  BD rr rr     	lda var_ch_EffParam, x
0009F5r 2  29 0F        	and #$0F
0009F7r 2  18           	clc
0009F8r 2  7D rr rr     	adc var_ch_Note, x
0009FBr 2  20 rr rr     	jsr ft_translate_freq_only
0009FEr 2  A9 00        	lda #$00
000A00r 2  9D rr rr     	sta var_ch_ArpeggioCycle, x
000A03r 2  4C rr rr     	jmp ft_post_effects
000A06r 2               
000A06r 2               ; Vibrato calculation
000A06r 2               ;
000A06r 2               ft_vibrato:
000A06r 2  BD rr rr     	lda var_ch_VibratoSpeed, x
000A09r 2  D0 01        	bne :+
000A0Br 2  60           	rts
000A0Cr 2  18           :	clc
000A0Dr 2  7D rr rr     	adc var_ch_VibratoPos, x		; Get next position
000A10r 2  29 3F        	and #$3F
000A12r 2  9D rr rr     	sta var_ch_VibratoPos, x
000A15r 2  C9 10        	cmp #$10
000A17r 2  90 1C        	bcc @Phase1
000A19r 2  C9 20        	cmp #$20
000A1Br 2  90 28        	bcc @Phase2
000A1Dr 2  C9 30        	cmp #$30
000A1Fr 2  90 3E        	bcc @Phase3
000A21r 2               	; Phase 4
000A21r 2               	; - 15 - (Phase - 48) + depth
000A21r 2  38           	sec
000A22r 2  E9 30        	sbc #$30
000A24r 2  85 rr        	sta var_Temp
000A26r 2  38           	sec
000A27r 2  A9 0F        	lda #$0F
000A29r 2  E5 rr        	sbc var_Temp
000A2Br 2               	;and #$0F
000A2Br 2  1D rr rr     	ora var_ch_VibratoDepth, x
000A2Er 2  A8           	tay
000A2Fr 2  B9 rr rr     	lda ft_vibrato_table, y
000A32r 2               ;	eor #$FF
000A32r 2               ;	sta var_Temp16
000A32r 2               ;	lda #$FF
000A32r 2               ;	sta var_Temp16 + 1
000A32r 2  4C rr rr     	jmp @Negate
000A35r 2               @Phase1:
000A35r 2                   ; Phase 1
000A35r 2               	; Phase + depth
000A35r 2  1D rr rr     	ora var_ch_VibratoDepth, x
000A38r 2  A8           	tay
000A39r 2  B9 rr rr     	lda ft_vibrato_table, y
000A3Cr 2  85 rr        	sta var_Temp16
000A3Er 2  A9 00        	lda #$00
000A40r 2  85 rr        	sta var_Temp16 + 1
000A42r 2  4C rr rr     	jmp @Calculate
000A45r 2               @Phase2:
000A45r 2                   ; Phase 2
000A45r 2               	; 15 - (Phase - 16) + depth
000A45r 2  38           	sec
000A46r 2  E9 10        	sbc #$10
000A48r 2  85 rr        	sta var_Temp
000A4Ar 2  38           	sec
000A4Br 2  A9 0F        	lda #$0F
000A4Dr 2  E5 rr        	sbc var_Temp
000A4Fr 2  1D rr rr     	ora var_ch_VibratoDepth, x
000A52r 2  A8           	tay
000A53r 2  B9 rr rr     	lda ft_vibrato_table, y
000A56r 2  85 rr        	sta var_Temp16
000A58r 2  A9 00        	lda #$00
000A5Ar 2  85 rr        	sta var_Temp16 + 1
000A5Cr 2  4C rr rr     	jmp @Calculate
000A5Fr 2               @Phase3:
000A5Fr 2                   ; Phase 3
000A5Fr 2               	; - (Phase - 32) + depth
000A5Fr 2  38           	sec
000A60r 2  E9 20        	sbc #$20
000A62r 2  1D rr rr     	ora var_ch_VibratoDepth, x
000A65r 2  A8           	tay
000A66r 2  B9 rr rr     	lda ft_vibrato_table, y
000A69r 2               
000A69r 2               @Negate:
000A69r 2  49 FF        	eor #$FF
000A6Br 2  85 rr        	sta var_Temp16
000A6Dr 2  A9 FF        	lda #$FF
000A6Fr 2  85 rr        	sta var_Temp16 + 1
000A71r 2  18           	clc
000A72r 2  A5 rr        	lda var_Temp16
000A74r 2  69 01        	adc #$01
000A76r 2  85 rr        	sta var_Temp16
000A78r 2  A5 rr        	lda var_Temp16 + 1
000A7Ar 2  69 00        	adc #$00
000A7Cr 2  85 rr        	sta var_Temp16 + 1
000A7Er 2               
000A7Er 2               @Calculate:
000A7Er 2               
000A7Er 2               	; Remove this if you don't need support for old vibrato
000A7Er 2  AD rr rr     	lda var_SongFlags
000A81r 2  29 02        	and #$02
000A83r 2  F0 1B        	beq :+
000A85r 2  A9 0F        	lda #$0F
000A87r 2  18           	clc
000A88r 2  7D rr rr     	adc var_ch_VibratoDepth, x
000A8Br 2  A8           	tay
000A8Cr 2  B9 rr rr     	lda ft_vibrato_table, y		; add depth + 1
000A8Fr 2  18           	clc
000A90r 2  69 01        	adc #$01
000A92r 2               ;	clc
000A92r 2  65 rr        	adc var_Temp16
000A94r 2  85 rr        	sta var_Temp16
000A96r 2  A5 rr        	lda var_Temp16 + 1
000A98r 2  69 00        	adc #$00
000A9Ar 2  85 rr        	sta var_Temp16 + 1
000A9Cr 2  46 rr        	lsr var_Temp16 + 1			; divide by 2
000A9Er 2  66 rr        	ror var_Temp16
000AA0r 2               :
000AA0r 2  38           	sec
000AA1r 2  BD rr rr     	lda var_ch_PeriodCalcLo, x
000AA4r 2  E5 rr        	sbc var_Temp16
000AA6r 2  9D rr rr     	sta var_ch_PeriodCalcLo, x
000AA9r 2  BD rr rr     	lda var_ch_PeriodCalcHi, x
000AACr 2  E5 rr        	sbc var_Temp16 + 1
000AAEr 2  9D rr rr     	sta var_ch_PeriodCalcHi, x
000AB1r 2  60           	rts
000AB2r 2               
000AB2r 2               
000AB2r 2               ; Tremolo calculation
000AB2r 2               ;
000AB2r 2               ft_tremolo:
000AB2r 2  BD rr rr     	lda var_ch_TremoloSpeed, x
000AB5r 2  D0 07        	bne @DoTremolo
000AB7r 2  BD rr rr     	lda var_ch_Volume, x
000ABAr 2  9D rr rr     	sta var_ch_OutVolume, x
000ABDr 2  60           	rts
000ABEr 2               @DoTremolo:
000ABEr 2  18           	clc
000ABFr 2  7D rr rr     	adc var_ch_TremoloPos, x		; Get next position
000AC2r 2  29 3F        	and #$3F
000AC4r 2  9D rr rr     	sta var_ch_TremoloPos, x
000AC7r 2  4A           	lsr a							; Divide by 2
000AC8r 2  C9 10        	cmp #$10
000ACAr 2  90 17        	bcc @Phase1
000ACCr 2               ; Phase 2
000ACCr 2               	; 15 - (Phase - 16) + depth
000ACCr 2  38           	sec
000ACDr 2  E9 10        	sbc #$10
000ACFr 2  85 rr        	sta var_Temp
000AD1r 2  38           	sec
000AD2r 2  A9 0F        	lda #$0F
000AD4r 2  E5 rr        	sbc var_Temp
000AD6r 2  1D rr rr     	ora var_ch_TremoloDepth, x
000AD9r 2  A8           	tay
000ADAr 2  B9 rr rr     	lda ft_vibrato_table, y
000ADDr 2  4A           	lsr a
000ADEr 2  85 rr        	sta var_Temp
000AE0r 2  4C rr rr     	jmp @Calculate
000AE3r 2               @Phase1:
000AE3r 2               	; Phase + depth
000AE3r 2  1D rr rr     	ora var_ch_TremoloDepth, x
000AE6r 2  A8           	tay
000AE7r 2  B9 rr rr     	lda ft_vibrato_table, y
000AEAr 2  4A           	lsr a
000AEBr 2  85 rr        	sta var_Temp
000AEDr 2               @Calculate:
000AEDr 2  38           	sec
000AEEr 2  BD rr rr     	lda var_ch_Volume, x
000AF1r 2  E5 rr        	sbc var_Temp
000AF3r 2  30 04        	bmi :+
000AF5r 2  9D rr rr     	sta var_ch_OutVolume, x
000AF8r 2  60           	rts
000AF9r 2  A9 00        :	lda #$00
000AFBr 2  9D rr rr     	sta var_ch_OutVolume, x
000AFEr 2  60           	rts
000AFFr 2               
000AFFr 2               
000AFFr 1               	.include "instrument.s"
000AFFr 2               ; Update the instrument for channel X
000AFFr 2               ;
000AFFr 2               ; I might consider storing the sequence address variables in ZP??
000AFFr 2               ;
000AFFr 2               ft_return:
000AFFr 2  60           	rts
000B00r 2               ft_update_channel:
000B00r 2               .ifdef USE_VRC7
000B00r 2               	cpx #VRC7_CHANNEL
000B00r 2               	bcc :+
000B00r 2               	cpx #VRC7_CHANNEL + 6
000B00r 2               	bcs :+
000B00r 2               	rts
000B00r 2               :
000B00r 2               .endif
000B00r 2               	; Volume
000B00r 2               	;
000B00r 2  BD rr rr     	lda var_ch_SeqVolume + SFX_WAVE_CHANS, x	; High part of address = 0 mean sequence is disabled
000B03r 2  F0 1A        	beq @SkipVolumeUpdate
000B05r 2  85 rr        	sta var_Temp_Pointer + 1
000B07r 2  BD rr rr     	lda var_ch_SeqVolume, x					; Store the sequence address in a zp variable
000B0Ar 2  85 rr        	sta var_Temp_Pointer
000B0Cr 2  BD rr rr     	lda var_ch_SequencePtr1, x				; Sequence item index
000B0Fr 2  C9 FF        	cmp #$FF
000B11r 2  F0 0C        	beq @SkipVolumeUpdate					; Skip if end is reached
000B13r 2  20 rr rr     	jsr ft_run_sequence						; Run an item in the sequence
000B16r 2  9D rr rr     	sta var_ch_SequencePtr1, x				; Store new index
000B19r 2  AD rr rr     	lda var_sequence_result					; Take care of the result
000B1Cr 2  9D rr rr     	sta var_ch_Volume, x
000B1Fr 2               @SkipVolumeUpdate:
000B1Fr 2               
000B1Fr 2               	; Arpeggio
000B1Fr 2               	;
000B1Fr 2  BD rr rr     	lda var_ch_SeqArpeggio + SFX_WAVE_CHANS, x
000B22r 2  F0 23        	beq @SkipArpeggioUpdate
000B24r 2  85 rr        	sta var_Temp_Pointer + 1
000B26r 2  BD rr rr     	lda var_ch_SeqArpeggio, x
000B29r 2  85 rr        	sta var_Temp_Pointer
000B2Br 2  BD rr rr     	lda var_ch_SequencePtr2, x
000B2Er 2  C9 FF        	cmp #$FF
000B30r 2  F0 15        	beq @SkipArpeggioUpdate
000B32r 2  20 rr rr     	jsr ft_run_sequence
000B35r 2  9D rr rr     	sta var_ch_SequencePtr2, x
000B38r 2  BD rr rr     	lda var_ch_Note, x					; No arp if no note
000B3Br 2  F0 0A        	beq @SkipArpeggioUpdate
000B3Dr 2  18           	clc
000B3Er 2  BD rr rr     	lda var_ch_Note, x
000B41r 2  6D rr rr     	adc var_sequence_result
000B44r 2  20 rr rr     	jsr ft_translate_freq_only
000B47r 2               @SkipArpeggioUpdate:
000B47r 2               
000B47r 2               	; Pitch bend
000B47r 2               	;
000B47r 2  BD rr rr     	lda var_ch_SeqPitch + SFX_WAVE_CHANS, x
000B4Ar 2  F0 32        	beq @SkipPitchUpdate
000B4Cr 2  85 rr        	sta var_Temp_Pointer + 1
000B4Er 2  BD rr rr     	lda var_ch_SeqPitch, x
000B51r 2  85 rr        	sta var_Temp_Pointer
000B53r 2  BD rr rr     	lda var_ch_SequencePtr3, x
000B56r 2  C9 FF        	cmp #$FF
000B58r 2  F0 24        	beq @SkipPitchUpdate
000B5Ar 2  20 rr rr     	jsr ft_run_sequence
000B5Dr 2  9D rr rr     	sta var_ch_SequencePtr3, x
000B60r 2               
000B60r 2               	; Check this
000B60r 2  18           	clc
000B61r 2  AD rr rr     	lda var_sequence_result
000B64r 2  7D rr rr     	adc var_ch_TimerPeriodLo, x
000B67r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000B6Ar 2  AD rr rr     	lda var_sequence_result
000B6Dr 2  10 04        	bpl @NoNegativePitch
000B6Fr 2  A9 FF        	lda #$FF
000B71r 2  30 02        	bmi @LoadLowPitch
000B73r 2               @NoNegativePitch:
000B73r 2  A9 00        	lda #$00
000B75r 2               @LoadLowPitch:
000B75r 2  7D rr rr     	adc var_ch_TimerPeriodHi, x
000B78r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000B7Br 2  20 rr rr     	jsr ft_limit_freq
000B7Er 2               	; ^^^^^^^^^^
000B7Er 2               
000B7Er 2               	; Save pitch
000B7Er 2               @SkipPitchUpdate:
000B7Er 2               	; HiPitch bend
000B7Er 2               	;
000B7Er 2  BD rr rr     	lda var_ch_SeqHiPitch + SFX_WAVE_CHANS, x
000B81r 2  F0 45        	beq @SkipHiPitchUpdate
000B83r 2  85 rr        	sta var_Temp_Pointer + 1
000B85r 2  BD rr rr     	lda var_ch_SeqHiPitch, x
000B88r 2  85 rr        	sta var_Temp_Pointer
000B8Ar 2  BD rr rr     	lda var_ch_SequencePtr4, x
000B8Dr 2  C9 FF        	cmp #$FF
000B8Fr 2  F0 37        	beq @SkipHiPitchUpdate
000B91r 2  20 rr rr     	jsr ft_run_sequence
000B94r 2  9D rr rr     	sta var_ch_SequencePtr4, x
000B97r 2               
000B97r 2               	; Check this
000B97r 2  AD rr rr     	lda var_sequence_result
000B9Ar 2  85 rr        	sta var_Temp16
000B9Cr 2  2A           	rol a
000B9Dr 2  90 07        	bcc @AddHiPitch
000B9Fr 2  A9 FF        	lda #$FF
000BA1r 2  85 rr        	sta var_Temp16 + 1
000BA3r 2  4C rr rr     	jmp @StoreHiPitch
000BA6r 2               @AddHiPitch:
000BA6r 2  A9 00        	lda #$00
000BA8r 2  85 rr        	sta var_Temp16 + 1
000BAAr 2               @StoreHiPitch:
000BAAr 2  A0 04        	ldy #$04
000BACr 2  18           :	clc
000BADr 2  26 rr        	rol var_Temp16 						; multiply by 2
000BAFr 2  26 rr        	rol var_Temp16 + 1
000BB1r 2  88           	dey
000BB2r 2  D0 F8        	bne :-
000BB4r 2               
000BB4r 2  18           	clc
000BB5r 2  A5 rr        	lda var_Temp16
000BB7r 2  7D rr rr     	adc var_ch_TimerPeriodLo, x
000BBAr 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000BBDr 2  A5 rr        	lda var_Temp16 + 1
000BBFr 2  7D rr rr     	adc var_ch_TimerPeriodHi, x
000BC2r 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000BC5r 2  20 rr rr     	jsr ft_limit_freq
000BC8r 2               	; ^^^^^^^^^^
000BC8r 2               
000BC8r 2               @SkipHiPitchUpdate:
000BC8r 2               	; Duty cycle/noise mode
000BC8r 2               	;
000BC8r 2  BD rr rr     	lda var_ch_SeqDutyCycle + SFX_WAVE_CHANS, x
000BCBr 2  F0 27        	beq @SkipDutyUpdate
000BCDr 2  85 rr        	sta var_Temp_Pointer + 1
000BCFr 2  BD rr rr     	lda var_ch_SeqDutyCycle, x
000BD2r 2  85 rr        	sta var_Temp_Pointer
000BD4r 2  BD rr rr     	lda var_ch_SequencePtr5, x
000BD7r 2  C9 FF        	cmp #$FF
000BD9r 2  F0 19        	beq @SkipDutyUpdate
000BDBr 2  20 rr rr     	jsr ft_run_sequence
000BDEr 2  9D rr rr     	sta var_ch_SequencePtr5, x
000BE1r 2  AD rr rr     	lda var_sequence_result
000BE4r 2  48           	pha
000BE5r 2  BD rr rr     	lda var_ch_DutyCycle, x
000BE8r 2  29 F0        	and #$F0
000BEAr 2  9D rr rr     	sta var_ch_DutyCycle, x
000BEDr 2  68           	pla
000BEEr 2  1D rr rr     	ora var_ch_DutyCycle, x
000BF1r 2  9D rr rr     	sta var_ch_DutyCycle, x
000BF4r 2               	; Save pitch
000BF4r 2               @SkipDutyUpdate:
000BF4r 2  60           	rts
000BF5r 2               
000BF5r 2               
000BF5r 2               ;
000BF5r 2               ; Process a sequence, next position is returned in A
000BF5r 2               ;
000BF5r 2               ; In: A = Sequence index
000BF5r 2               ; Out: A = New sequence index
000BF5r 2               ;
000BF5r 2               ft_run_sequence:
000BF5r 2  18           	clc
000BF6r 2  69 03        	adc #$03						; Offset is 3 items
000BF8r 2  A8           	tay
000BF9r 2  B1 rr        	lda (var_Temp_Pointer), y
000BFBr 2  8D rr rr     	sta var_sequence_result
000BFEr 2  88           	dey
000BFFr 2  88           	dey
000C00r 2  98           	tya
000C01r 2  A0 00        	ldy #$00						; Check if halt point
000C03r 2  D1 rr        	cmp (var_Temp_Pointer), y
000C05r 2  F0 07        	beq @HaltSequence
000C07r 2  A0 02        	ldy #$02						; Check release point
000C09r 2  D1 rr        	cmp (var_Temp_Pointer), y
000C0Br 2  F0 21        	beq @ReleasePoint
000C0Dr 2  60           	rts
000C0Er 2               @HaltSequence:						; Stop the sequence
000C0Er 2  C8           	iny
000C0Fr 2  B1 rr        	lda (var_Temp_Pointer), y		; Check loop point
000C11r 2  C9 FF        	cmp #$FF
000C13r 2  D0 05        	bne @LoopSequence
000C15r 2  A9 FF        	lda #$FF						; Disable sequence by loading $FF into length
000C17r 2  60           	rts
000C18r 2               @Skip:
000C18r 2  A5 rr        	lda	var_Temp
000C1Ar 2               @LoopSequence:						; Just return A
000C1Ar 2  48               pha
000C1Br 2  BD rr rr     	lda var_ch_State, x
000C1Er 2  D0 02        	bne :+
000C20r 2  68           	pla
000C21r 2  60           	rts								; Return new index
000C22r 2  A0 02        :	ldy #$02						; Check release point
000C24r 2  B1 rr        	lda (var_Temp_Pointer), y
000C26r 2  D0 02        	bne :+
000C28r 2  68           	pla								; Release point not found, loop
000C29r 2  60            	rts
000C2Ar 2  68           :	pla								; Release point found, don't loop
000C2Br 2  A9 FF        	lda #$FF
000C2Dr 2  60           	rts
000C2Er 2               @ReleasePoint:						; Release point has been reached
000C2Er 2  85 rr        	sta	var_Temp					; Save index
000C30r 2  BD rr rr     	lda var_ch_State, x
000C33r 2  D0 E3        	bne @Skip						; Note is releasing, continue until end
000C35r 2  88           	dey
000C36r 2  B1 rr        	lda (var_Temp_Pointer), y		; Check loop point
000C38r 2  C9 FF        	cmp #$FF
000C3Ar 2  D0 DE        	bne @LoopSequence
000C3Cr 2  A5 rr        	lda var_Temp
000C3Er 2  38           	sec								; Step back one step
000C3Fr 2  E9 01        	sbc #$01
000C41r 2  60           	rts
000C42r 2               
000C42r 2               ; Called on note release instruction
000C42r 2               ;
000C42r 2               ft_instrument_release:
000C42r 2  98               tya
000C43r 2  48               pha
000C44r 2  BD rr rr     	lda var_ch_SeqVolume + SFX_WAVE_CHANS, x
000C47r 2  F0 10        	beq :+
000C49r 2  85 rr        	sta var_Temp_Pointer + 1
000C4Br 2  BD rr rr     	lda var_ch_SeqVolume, x
000C4Er 2  85 rr        	sta var_Temp_Pointer
000C50r 2  A0 02        	ldy #$02
000C52r 2  B1 rr        	lda (var_Temp_Pointer), y
000C54r 2  F0 03        	beq :+
000C56r 2  9D rr rr     	sta var_ch_SequencePtr1, x
000C59r 2  BD rr rr     :	lda var_ch_SeqArpeggio + SFX_WAVE_CHANS, x
000C5Cr 2  F0 10        	beq :+
000C5Er 2  85 rr        	sta var_Temp_Pointer + 1
000C60r 2  BD rr rr     	lda var_ch_SeqArpeggio, x
000C63r 2  85 rr        	sta var_Temp_Pointer
000C65r 2  A0 02        	ldy #$02
000C67r 2  B1 rr        	lda (var_Temp_Pointer), y
000C69r 2  F0 03        	beq :+
000C6Br 2  9D rr rr     	sta var_ch_SequencePtr2, x
000C6Er 2  BD rr rr     :	lda var_ch_SeqPitch + SFX_WAVE_CHANS, x
000C71r 2  F0 10        	beq :+
000C73r 2  85 rr        	sta var_Temp_Pointer + 1
000C75r 2  BD rr rr     	lda var_ch_SeqPitch, x
000C78r 2  85 rr        	sta var_Temp_Pointer
000C7Ar 2  A0 02        	ldy #$02
000C7Cr 2  B1 rr        	lda (var_Temp_Pointer), y
000C7Er 2  F0 03        	beq :+
000C80r 2  9D rr rr     	sta var_ch_SequencePtr3, x
000C83r 2  BD rr rr     :	lda var_ch_SeqHiPitch + SFX_WAVE_CHANS, x
000C86r 2  F0 10        	beq :+
000C88r 2  85 rr        	sta var_Temp_Pointer + 1
000C8Ar 2  BD rr rr     	lda var_ch_SeqHiPitch, x
000C8Dr 2  85 rr        	sta var_Temp_Pointer
000C8Fr 2  A0 02        	ldy #$02
000C91r 2  B1 rr        	lda (var_Temp_Pointer), y
000C93r 2  F0 03        	beq :+
000C95r 2  9D rr rr     	sta var_ch_SequencePtr4, x
000C98r 2  BD rr rr     :	lda var_ch_SeqDutyCycle + SFX_WAVE_CHANS, x
000C9Br 2  F0 10        	beq :+
000C9Dr 2  85 rr        	sta var_Temp_Pointer + 1
000C9Fr 2  BD rr rr     	lda var_ch_SeqDutyCycle, x
000CA2r 2  85 rr        	sta var_Temp_Pointer
000CA4r 2  A0 02        	ldy #$02
000CA6r 2  B1 rr        	lda (var_Temp_Pointer), y
000CA8r 2  F0 03        	beq :+
000CAAr 2  9D rr rr     	sta var_ch_SequencePtr5, x
000CADr 2  68           :   pla
000CAEr 2  A8           	tay
000CAFr 2  60           	rts
000CB0r 2               
000CB0r 2               ; Reset instrument sequences
000CB0r 2               ;
000CB0r 2               ft_reset_instrument:
000CB0r 2               
000CB0r 2               .ifdef USE_FDS
000CB0r 2               	cpx #FDS_CHANNEL
000CB0r 2               	bne :+
000CB0r 2               	lda var_ch_ModDelay
000CB0r 2               	sta var_ch_ModDelayTick
000CB0r 2               ;	lda #$00
000CB0r 2               ;	sta $4085
000CB0r 2               ;	lda #$80
000CB0r 2               ;	sta $4087
000CB0r 2               ;	rts
000CB0r 2               :
000CB0r 2               .endif
000CB0r 2               
000CB0r 2  A9 00        	lda #$00
000CB2r 2  9D rr rr     	sta var_ch_SequencePtr1, x
000CB5r 2  9D rr rr     	sta var_ch_SequencePtr2, x
000CB8r 2  9D rr rr     	sta var_ch_SequencePtr3, x
000CBBr 2  9D rr rr     	sta var_ch_SequencePtr4, x
000CBEr 2  9D rr rr     	sta var_ch_SequencePtr5, x
000CC1r 2  60           	rts
000CC2r 2               
000CC2r 2               ; Load the instrument in A for channel X (Y must be saved)
000CC2r 2               ;
000CC2r 2               ; Optimize
000CC2r 2               ;
000CC2r 2               ft_load_instrument:
000CC2r 2               
000CC2r 2               .ifdef USE_VRC7
000CC2r 2               	sta var_Temp_Inst		; Save current instrument number
000CC2r 2               .endif
000CC2r 2               
000CC2r 2  84 rr        	sty var_Temp
000CC4r 2  A0 00        	ldy #$00
000CC6r 2               
000CC6r 2               	; Instrument_pointer_list + a => instrument_address
000CC6r 2               	; instrument_address + ft_music_addr => instrument_data
000CC6r 2               
000CC6r 2               	; Get the instrument data pointer
000CC6r 2  18           	clc
000CC7r 2  6D rr rr     	adc var_Instrument_list
000CCAr 2  85 rr        	sta var_Temp16
000CCCr 2  98           	tya
000CCDr 2  6D rr rr     	adc var_Instrument_list + 1
000CD0r 2  85 rr        	sta var_Temp16 + 1
000CD2r 2  18           	clc
000CD3r 2               
000CD3r 2               	; Get the instrument
000CD3r 2  B1 rr        	lda (var_Temp16), y
000CD5r 2  6D rr rr     	adc ft_music_addr
000CD8r 2  85 rr        	sta var_Temp_Pointer
000CDAr 2  C8           	iny
000CDBr 2  B1 rr        	lda (var_Temp16), y
000CDDr 2  6D rr rr     	adc ft_music_addr + 1
000CE0r 2  85 rr        	sta var_Temp_Pointer + 1
000CE2r 2               
000CE2r 2               .ifdef USE_FDS
000CE2r 2               	; FDS instruments
000CE2r 2               	cpx #FDS_CHANNEL
000CE2r 2               	bne @SkipFDS
000CE2r 2               
000CE2r 2               	; Read FDS instrument
000CE2r 2               	ldy #$00
000CE2r 2               	lda (var_Temp_Pointer), y	; Load wave index
000CE2r 2               	iny
000CE2r 2               	pha
000CE2r 2               
000CE2r 2               	; Load modulation table
000CE2r 2               	jsr ft_reset_modtable
000CE2r 2               :
000CE2r 2               	lda (var_Temp_Pointer), y
000CE2r 2               	pha
000CE2r 2               	and #$07
000CE2r 2               	sta $4088
000CE2r 2               	pla
000CE2r 2               	lsr a
000CE2r 2               	lsr a
000CE2r 2               	lsr a
000CE2r 2               	sta $4088
000CE2r 2               	iny
000CE2r 2               	cpy #$11
000CE2r 2               	bne :-
000CE2r 2               
000CE2r 2               	lda (var_Temp_Pointer), y	; Modulation delay
000CE2r 2               	iny
000CE2r 2               	sta var_ch_ModDelay
000CE2r 2               	lda (var_Temp_Pointer), y	; Modulation depth
000CE2r 2               	iny
000CE2r 2               	sta var_ch_ModDepth
000CE2r 2               	lda (var_Temp_Pointer), y	; Modulation freq low
000CE2r 2               	iny
000CE2r 2               	sta var_ch_ModRate
000CE2r 2               	lda (var_Temp_Pointer), y	; Modulation freq high
000CE2r 2               	sta var_ch_ModRate + 1
000CE2r 2               
000CE2r 2               	clc
000CE2r 2               	lda var_Temp_Pointer
000CE2r 2               	adc #$15
000CE2r 2               	sta var_Temp16
000CE2r 2               	lda var_Temp_Pointer + 1
000CE2r 2               	adc #$00
000CE2r 2               	sta var_Temp16 + 1
000CE2r 2               
000CE2r 2               	pla							; Load wave index
000CE2r 2               
000CE2r 2               	jsr ft_load_fds_wave
000CE2r 2               
000CE2r 2               	lda var_Temp16
000CE2r 2               	sta var_Temp_Pointer
000CE2r 2               	lda var_Temp16 + 1
000CE2r 2               	sta var_Temp_Pointer + 1
000CE2r 2               
000CE2r 2               ;	jmp @Return
000CE2r 2               @SkipFDS:
000CE2r 2               .endif
000CE2r 2               
000CE2r 2               .ifdef USE_VRC7
000CE2r 2               	; VRC7 instruments
000CE2r 2               	cpx #VRC7_CHANNEL
000CE2r 2               	bcc @SkipVRC7
000CE2r 2               	; Read VRC7 instrument
000CE2r 2               	ldy #$00
000CE2r 2               	lda (var_Temp_Pointer), y		; Load patch number
000CE2r 2               	sta var_ch_vrc7_Patch - VRC7_CHANNEL, x			; vrc7 channel offset
000CE2r 2               	sta var_ch_vrc7_DefPatch - VRC7_CHANNEL, x
000CE2r 2               	bne :++							; Skip custom settings if patch > 0
000CE2r 2               	lda var_Temp_Inst
000CE2r 2               	cmp var_ch_vrc7_CustomPatch			; Check if it's the same custom instrument
000CE2r 2               	beq :++							; Skip if it is
000CE2r 2               	; Load custom instrument regs
000CE2r 2               	txa
000CE2r 2               	pha
000CE2r 2               	ldx #$00
000CE2r 2               :	iny
000CE2r 2               	lda (var_Temp_Pointer), y		; Load register
000CE2r 2               	stx $9010						; Register index
000CE2r 2               	sta $9030						; Store the setting
000CE2r 2               	inx
000CE2r 2               	cpx #$08
000CE2r 2               	bne :-
000CE2r 2               	pla
000CE2r 2               	tax
000CE2r 2               	lda var_Temp_Inst
000CE2r 2               	sta var_ch_vrc7_CustomPatch
000CE2r 2               : 	;jmp @Return
000CE2r 2               	ldy var_Temp
000CE2r 2               	rts
000CE2r 2               @SkipVRC7:
000CE2r 2               .endif
000CE2r 2               
000CE2r 2               	; Read instrument data, var_Temp_Pointer points to instrument data
000CE2r 2  A0 00        	ldy #$00
000CE4r 2  B1 rr        	lda (var_Temp_Pointer), y		; sequence switch
000CE6r 2  85 rr        	sta var_Temp3
000CE8r 2  C8           	iny
000CE9r 2               
000CE9r 2               ; Macro used to load instrument envelopes
000CE9r 2               .macro load_inst seq_addr, seq_ptr
000CE9r 2               
000CE9r 2               	ror var_Temp3
000CE9r 2               	bcc	:++
000CE9r 2               	clc
000CE9r 2               	lda (var_Temp_Pointer), y
000CE9r 2               	adc ft_music_addr
000CE9r 2               	sta var_Temp16
000CE9r 2               	iny
000CE9r 2               	lda (var_Temp_Pointer), y
000CE9r 2               	adc ft_music_addr + 1
000CE9r 2               	sta var_Temp16 + 1
000CE9r 2               	iny
000CE9r 2               
000CE9r 2               	lda var_Temp16
000CE9r 2               	cmp seq_addr, x
000CE9r 2               	bne :+
000CE9r 2               	lda var_Temp16 + 1
000CE9r 2               	cmp seq_addr + SFX_WAVE_CHANS, x
000CE9r 2               ;	bne :+
000CE9r 2               
000CE9r 2               	; Both equal
000CE9r 2               
000CE9r 2               	jmp :+++
000CE9r 2               
000CE9r 2               :	lda var_Temp16
000CE9r 2               	sta seq_addr, x
000CE9r 2               	lda var_Temp16 + 1
000CE9r 2               	sta seq_addr + SFX_WAVE_CHANS, x
000CE9r 2               
000CE9r 2               	lda #$00
000CE9r 2               	sta seq_ptr, x
000CE9r 2               
000CE9r 2               	jmp :++		; branch always
000CE9r 2               :	lda #$00
000CE9r 2               	sta seq_addr, x
000CE9r 2               	sta seq_addr + SFX_WAVE_CHANS, x
000CE9r 2               :
000CE9r 2               .endmacro
000CE9r 2               
000CE9r 2  66 rr 90 32      load_inst var_ch_SeqVolume, var_ch_SequencePtr1
000CEDr 2  18 B1 rr 6D  
000CF1r 2  rr rr 85 rr  
000D27r 2  66 rr 90 32      load_inst var_ch_SeqArpeggio, var_ch_SequencePtr2
000D2Br 2  18 B1 rr 6D  
000D2Fr 2  rr rr 85 rr  
000D65r 2  66 rr 90 32      load_inst var_ch_SeqPitch, var_ch_SequencePtr3
000D69r 2  18 B1 rr 6D  
000D6Dr 2  rr rr 85 rr  
000DA3r 2  66 rr 90 32      load_inst var_ch_SeqHiPitch, var_ch_SequencePtr4
000DA7r 2  18 B1 rr 6D  
000DABr 2  rr rr 85 rr  
000DE1r 2  66 rr 90 32      load_inst var_ch_SeqDutyCycle, var_ch_SequencePtr5
000DE5r 2  18 B1 rr 6D  
000DE9r 2  rr rr 85 rr  
000E1Fr 2               
000E1Fr 2  A4 rr        	ldy var_Temp
000E21r 2               
000E21r 2  60           	rts
000E22r 2               
000E22r 2               ; Make sure the frequency doesn't exceed max or min
000E22r 2               ft_limit_freq:
000E22r 2  BD rr rr     	lda var_ch_TimerPeriodHi, x
000E25r 2  30 0F        	bmi @LimitMin						; period < 0
000E27r 2               .ifdef USE_VRC6
000E27r 2               	cpx #VRC6_CHANNELS
000E27r 2               	bcc :+
000E27r 2               	cmp #$10							; period > $FFF
000E27r 2               	bcc @NoLimit
000E27r 2               	lda #$0F
000E27r 2               	sta var_ch_TimerPeriodHi, x
000E27r 2               	lda #$FF
000E27r 2               	sta var_ch_TimerPeriodLo, x
000E27r 2               	rts
000E27r 2               :
000E27r 2               .endif
000E27r 2               .ifdef USE_FDS
000E27r 2               	cpx #FDS_CHANNEL
000E27r 2               	bne :+
000E27r 2               	cmp #$11							; period > $1000?
000E27r 2               	bcc @NoLimit
000E27r 2               	lda #$10
000E27r 2               	sta var_ch_TimerPeriodHi, x
000E27r 2               	lda #$FF
000E27r 2               	sta var_ch_TimerPeriodLo, x
000E27r 2               	rts
000E27r 2               :
000E27r 2               .endif
000E27r 2  C9 08        	cmp #$08							; period > $7FF
000E29r 2  90 0A        	bcc @NoLimit
000E2Br 2  A9 07        	lda #$07
000E2Dr 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000E30r 2  A9 FF        	lda #$FF
000E32r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000E35r 2               @NoLimit:
000E35r 2  60           	rts
000E36r 2               @LimitMin:
000E36r 2  A9 00        	lda #$00
000E38r 2  9D rr rr     	sta var_ch_TimerPeriodLo, x
000E3Br 2  9D rr rr     	sta var_ch_TimerPeriodHi, x
000E3Er 2  60           	rts
000E3Fr 2               
000E3Fr 1               	.include "apu.s"
000E3Fr 2               ;
000E3Fr 2               ; Updates the APU registers. x and y are free to use
000E3Fr 2               ;
000E3Fr 2               
000E3Fr 2               .if 0
000E3Fr 2               ; Found this on nesdev bbs by blargg,
000E3Fr 2               ; this can replace the volume table but takes a little more CPU
000E3Fr 2               ft_get_volume:
000E3Fr 2               
000E3Fr 2               	lda var_ch_VolColumn, x
000E3Fr 2               	lsr a
000E3Fr 2               	lsr a
000E3Fr 2               	lsr a
000E3Fr 2               	sta var_Temp
000E3Fr 2               	lda var_ch_OutVolume, x
000E3Fr 2               	sta var_Temp2
000E3Fr 2               
000E3Fr 2                   lda var_Temp				; 4x4 multiplication
000E3Fr 2                   lsr var_Temp2
000E3Fr 2                   bcs :+
000E3Fr 2                   lsr a
000E3Fr 2               :   lsr var_Temp2
000E3Fr 2                   bcc :+
000E3Fr 2                   adc var_Temp
000E3Fr 2               :   lsr a
000E3Fr 2                   lsr var_Temp2
000E3Fr 2                   bcc :+
000E3Fr 2                   adc var_Temp
000E3Fr 2               :   lsr a
000E3Fr 2                   lsr var_Temp2
000E3Fr 2                   bcc :+
000E3Fr 2                   adc var_Temp
000E3Fr 2               :   lsr a
000E3Fr 2               	beq :+
000E3Fr 2               	rts
000E3Fr 2               :	lda var_Temp
000E3Fr 2               	ora var_ch_OutVolume, x
000E3Fr 2               	beq :+
000E3Fr 2               	lda #$01					; Round up to 1
000E3Fr 2               :	rts
000E3Fr 2               .endif
000E3Fr 2               
000E3Fr 2               ft_update_apu:
000E3Fr 2  AD rr rr     	lda var_PlayerFlags
000E42r 2  D0 11        	bne @Play
000E44r 2  A9 00        	lda #$00					; Kill all channels
000E46r 2  8D 15 40     	sta $4015
000E49r 2  60           	rts
000E4Ar 2               @KillSweepUnit:					; Reset sweep unit to avoid strange problems
000E4Ar 2  A9 C0        	lda #$C0
000E4Cr 2  8D 17 40     	sta $4017
000E4Fr 2  A9 40        	lda #$40
000E51r 2  8D 17 40     	sta $4017
000E54r 2  60           	rts
000E55r 2               @Play:
000E55r 2               
000E55r 2               	;
000E55r 2               	; Square 1
000E55r 2               	;
000E55r 2  AD rr rr     	lda var_Channels
000E58r 2  29 01        	and #$01
000E5Ar 2  D0 03        	bne :+
000E5Cr 2  4C rr rr     	jmp @Square2
000E5Fr 2               :
000E5Fr 2  AD rr rr     	lda var_ch_Note				; Kill channel if note = off
000E62r 2  F0 61        	beq @KillSquare1
000E64r 2               
000E64r 2               	; Calculate volume
000E64r 2               .if 0
000E64r 2               	ldx #$00
000E64r 2               	jsr ft_get_volume
000E64r 2               	beq @KillSquare1
000E64r 2               .endif
000E64r 2               	; Calculate volume
000E64r 2  AD rr rr     	lda var_ch_VolColumn + 0		; Kill channel if volume column = 0
000E67r 2  0A           	asl a
000E68r 2  29 F0        	and #$F0
000E6Ar 2  F0 59        	beq @KillSquare1
000E6Cr 2  85 rr        	sta var_Temp
000E6Er 2  AD rr rr     	lda var_ch_OutVolume + 0
000E71r 2  F0 52        	beq @KillSquare1
000E73r 2  05 rr        	ora var_Temp
000E75r 2  AA           	tax
000E76r 2  BD rr rr     	lda ft_volume_table, x
000E79r 2               
000E79r 2               	; Write to registers
000E79r 2  48           	pha
000E7Ar 2  AD rr rr     	lda var_ch_DutyCycle
000E7Dr 2  29 03        	and #$03
000E7Fr 2  AA           	tax
000E80r 2  68           	pla
000E81r 2  1D rr rr     	ora ft_duty_table, x		; Add volume
000E84r 2  09 30        	ora #$30					; And disable length counter and envelope
000E86r 2  8D 00 40     	sta $4000
000E89r 2               	; Period table isn't limited to $7FF anymore
000E89r 2  AD rr rr     	lda var_ch_PeriodCalcHi
000E8Cr 2  29 F8        	and #$F8
000E8Er 2  F0 0A        	beq @TimerOverflow1
000E90r 2  A9 07        	lda #$07
000E92r 2  8D rr rr     	sta var_ch_PeriodCalcHi
000E95r 2  A9 FF        	lda #$FF
000E97r 2  8D rr rr     	sta var_ch_PeriodCalcLo
000E9Ar 2               @TimerOverflow1:
000E9Ar 2               
000E9Ar 2  AD rr rr     	lda var_ch_Sweep 			; Check if sweep is active
000E9Dr 2  F0 2E        	beq @NoSquare1Sweep
000E9Fr 2  29 80        	and #$80
000EA1r 2  F0 46        	beq @Square2				; See if sweep is triggered, if then don't touch sound registers until next note
000EA3r 2               
000EA3r 2  AD rr rr     	lda var_ch_Sweep 			; Trigger sweep
000EA6r 2  8D 01 40     	sta $4001
000EA9r 2  29 7F        	and #$7F
000EABr 2  8D rr rr     	sta var_ch_Sweep
000EAEr 2               
000EAEr 2  20 rr rr     	jsr @KillSweepUnit
000EB1r 2               
000EB1r 2  AD rr rr     	lda var_ch_PeriodCalcLo
000EB4r 2  8D 02 40     	sta $4002
000EB7r 2  AD rr rr     	lda var_ch_PeriodCalcHi
000EBAr 2  8D 03 40     	sta $4003
000EBDr 2  A9 FF        	lda #$FF
000EBFr 2  8D rr rr     	sta var_ch_PrevFreqHigh
000EC2r 2               
000EC2r 2  4C rr rr     	jmp @Square2
000EC5r 2               
000EC5r 2               @KillSquare1:
000EC5r 2  A9 30        	lda #$30
000EC7r 2  8D 00 40     	sta $4000
000ECAr 2  4C rr rr     	jmp @Square2
000ECDr 2               
000ECDr 2               @NoSquare1Sweep:				; No Sweep
000ECDr 2  A9 08        	lda #$08
000ECFr 2  8D 01 40     	sta $4001
000ED2r 2  20 rr rr     	jsr @KillSweepUnit
000ED5r 2  AD rr rr     	lda var_ch_PeriodCalcLo
000ED8r 2  8D 02 40     	sta $4002
000EDBr 2  AD rr rr     	lda var_ch_PeriodCalcHi
000EDEr 2  CD rr rr     	cmp var_ch_PrevFreqHigh
000EE1r 2  F0 06        	beq @SkipHighPartSq1
000EE3r 2  8D 03 40     	sta $4003
000EE6r 2  8D rr rr     	sta var_ch_PrevFreqHigh
000EE9r 2               @SkipHighPartSq1:
000EE9r 2               ;	jmp @Square2
000EE9r 2               
000EE9r 2               	;
000EE9r 2               	; Square 2
000EE9r 2               	;
000EE9r 2               @Square2:
000EE9r 2  AD rr rr     	lda var_Channels
000EECr 2  29 02        	and #$02
000EEEr 2  D0 03        	bne :+
000EF0r 2  4C rr rr     	jmp @Triangle
000EF3r 2               :
000EF3r 2  AD rr rr     	lda var_ch_Note + 1
000EF6r 2               ;	beq @KillSquare2
000EF6r 2  D0 03        	bne :+
000EF8r 2  4C rr rr     	jmp @KillSquare2
000EFBr 2               :
000EFBr 2               
000EFBr 2               	.if 1
000EFBr 2               	; Calculate volume
000EFBr 2  AD rr rr     	lda var_ch_VolColumn + 1		; Kill channel if volume column = 0
000EFEr 2  0A           	asl a
000EFFr 2  29 F0        	and #$F0
000F01r 2  F0 78        	beq @KillSquare2
000F03r 2  85 rr        	sta var_Temp
000F05r 2  AD rr rr     	lda var_ch_OutVolume + 1
000F08r 2  F0 71        	beq @KillSquare2
000F0Ar 2  05 rr        	ora var_Temp
000F0Cr 2  AA           	tax
000F0Dr 2  BD rr rr     	lda ft_volume_table, x
000F10r 2               	.endif
000F10r 2               
000F10r 2               	.if 0
000F10r 2               	ldx #$01
000F10r 2               	jsr ft_get_volume
000F10r 2               	beq @KillSquare2
000F10r 2               	.endif
000F10r 2               
000F10r 2               	; Write to registers
000F10r 2  48           	pha
000F11r 2  AD rr rr     	lda var_ch_DutyCycle + 1
000F14r 2  29 03        	and #$03
000F16r 2  AA           	tax
000F17r 2  68           	pla
000F18r 2  1D rr rr     	ora ft_duty_table, x
000F1Br 2  09 30        	ora #$30
000F1Dr 2  8D 04 40     	sta $4004
000F20r 2               	; Period table isn't limited to $7FF anymore
000F20r 2  AD rr rr     	lda var_ch_PeriodCalcHi + 1
000F23r 2  29 F8        	and #$F8
000F25r 2  F0 0A        	beq @TimerOverflow2
000F27r 2  A9 07        	lda #$07
000F29r 2  8D rr rr     	sta var_ch_PeriodCalcHi + 1
000F2Cr 2  A9 FF        	lda #$FF
000F2Er 2  8D rr rr     	sta var_ch_PeriodCalcLo + 1
000F31r 2               @TimerOverflow2:
000F31r 2               
000F31r 2  AD rr rr     	lda var_ch_Sweep + 1		; Check if there should be sweep
000F34r 2  F0 26        	beq @NoSquare2Sweep
000F36r 2  29 80        	and #$80
000F38r 2  F0 46        	beq @Triangle				; See if sweep is triggered
000F3Ar 2  AD rr rr     	lda var_ch_Sweep + 1		; Trigger sweep
000F3Dr 2  8D 05 40     	sta $4005
000F40r 2  29 7F        	and #$7F
000F42r 2  8D rr rr     	sta var_ch_Sweep + 1
000F45r 2               
000F45r 2  20 rr rr     	jsr @KillSweepUnit
000F48r 2               
000F48r 2  AD rr rr     	lda var_ch_PeriodCalcLo + 1	; Could this be done by that below? I don't know
000F4Br 2  8D 06 40     	sta $4006
000F4Er 2  AD rr rr     	lda var_ch_PeriodCalcHi + 1
000F51r 2  8D 07 40     	sta $4007
000F54r 2  A9 FF        	lda #$FF
000F56r 2  8D rr rr     	sta var_ch_PrevFreqHigh + 1
000F59r 2               
000F59r 2  4C rr rr     	jmp @Triangle
000F5Cr 2               @NoSquare2Sweep:				; No Sweep
000F5Cr 2  A9 08        	lda #$08
000F5Er 2  8D 05 40     	sta $4005
000F61r 2  20 rr rr     	jsr @KillSweepUnit
000F64r 2  AD rr rr     	lda var_ch_PeriodCalcLo + 1
000F67r 2  8D 06 40     	sta $4006
000F6Ar 2  AD rr rr     	lda var_ch_PeriodCalcHi + 1
000F6Dr 2  CD rr rr     	cmp var_ch_PrevFreqHigh + 1
000F70r 2  F0 06        	beq @SkipHighPartSq2
000F72r 2  8D 07 40     	sta $4007
000F75r 2  8D rr rr     	sta var_ch_PrevFreqHigh + 1
000F78r 2               @SkipHighPartSq2:
000F78r 2  4C rr rr     	jmp @Triangle
000F7Br 2               @KillSquare2:
000F7Br 2  A9 30        	lda #$30
000F7Dr 2  8D 04 40     	sta $4004
000F80r 2               
000F80r 2               @Triangle:
000F80r 2  AD rr rr     	lda var_Channels
000F83r 2  29 04        	and #$04
000F85r 2  F0 34        	beq @Noise
000F87r 2               	;
000F87r 2               	; Triangle
000F87r 2               	;
000F87r 2  AD rr rr     	lda var_ch_Volume + 2
000F8Ar 2  F0 2A        	beq @KillTriangle
000F8Cr 2  AD rr rr     	lda var_ch_Note + 2
000F8Fr 2               	;ora var_ch_Note + 2
000F8Fr 2  F0 25        	beq @KillTriangle
000F91r 2  A9 81        	lda #$81
000F93r 2  8D 08 40     	sta $4008
000F96r 2               	; Period table isn't limited to $7FF anymore
000F96r 2  AD rr rr     	lda var_ch_PeriodCalcHi + 2
000F99r 2  29 F8        	and #$F8
000F9Br 2  F0 0A        	beq @TimerOverflow3
000F9Dr 2  A9 07        	lda #$07
000F9Fr 2  8D rr rr     	sta var_ch_PeriodCalcHi + 2
000FA2r 2  A9 FF        	lda #$FF
000FA4r 2  8D rr rr     	sta var_ch_PeriodCalcLo + 2
000FA7r 2               @TimerOverflow3:
000FA7r 2               ;	lda #$08
000FA7r 2               ;	sta $4009
000FA7r 2  AD rr rr     	lda var_ch_PeriodCalcLo + 2
000FAAr 2  8D 0A 40     	sta $400A
000FADr 2  AD rr rr     	lda var_ch_PeriodCalcHi + 2
000FB0r 2  8D 0B 40     	sta $400B
000FB3r 2  4C rr rr     	jmp @SkipTriangleKill
000FB6r 2               @KillTriangle:
000FB6r 2  A9 00        	lda #$00
000FB8r 2  8D 08 40     	sta $4008
000FBBr 2               @SkipTriangleKill:
000FBBr 2               
000FBBr 2               	;
000FBBr 2               	; Noise
000FBBr 2               	;
000FBBr 2               @Noise:
000FBBr 2  AD rr rr     	lda var_Channels
000FBEr 2  29 08        	and #$08
000FC0r 2  F0 45        	beq @DPCM
000FC2r 2               
000FC2r 2  AD rr rr     	lda var_ch_Note + 3
000FC5r 2  F0 3B        	beq @KillNoise
000FC7r 2               	; Calculate volume
000FC7r 2               	.if 1
000FC7r 2  AD rr rr     	lda var_ch_VolColumn + 3		; Kill channel if volume column = 0
000FCAr 2  0A           	asl a
000FCBr 2  29 F0        	and #$F0
000FCDr 2  85 rr        	sta var_Temp
000FCFr 2  F0 31        	beq @KillNoise
000FD1r 2  AD rr rr     	lda var_ch_OutVolume + 3
000FD4r 2  F0 2C        	beq @KillNoise
000FD6r 2  05 rr        	ora var_Temp
000FD8r 2  AA           	tax
000FD9r 2  BD rr rr     	lda ft_volume_table, x
000FDCr 2               	.endif
000FDCr 2               ;	ldx #$03
000FDCr 2               ;	jsr ft_get_volume
000FDCr 2               ;	beq @KillNoise
000FDCr 2               
000FDCr 2               	; Write to registers
000FDCr 2  09 30        	ora #$30
000FDEr 2  8D 0C 40     	sta $400C
000FE1r 2  A9 00        	lda #$00
000FE3r 2  8D 0D 40     	sta $400D
000FE6r 2  AD rr rr     	lda var_ch_DutyCycle + 3
000FE9r 2               ;	and #$01
000FE9r 2  6A           	ror a
000FEAr 2  6A           	ror a
000FEBr 2  29 80        	and #$80
000FEDr 2  85 rr        	sta var_Temp
000FEFr 2  AD rr rr     	lda var_ch_PeriodCalcLo + 3
000FF2r 2  29 0F        	and #$0F
000FF4r 2  49 0F        	eor #$0F
000FF6r 2  05 rr        	ora var_Temp
000FF8r 2  8D 0E 40     	sta $400E
000FFBr 2  A9 00        	lda #$00
000FFDr 2  8D 0F 40     	sta $400F
001000r 2  F0 05        	beq @DPCM
001002r 2               @KillNoise:
001002r 2  A9 30        	lda #$30
001004r 2  8D 0C 40     	sta $400C
001007r 2               @DPCM:
001007r 2               	;
001007r 2               	; DPCM
001007r 2               	;
001007r 2               .ifdef USE_DPCM
001007r 2  AD rr rr     	lda var_Channels
00100Ar 2  29 10        	and #$10
00100Cr 2  F0 73        	beq @Return
00100Er 2               
00100Er 2  AD rr rr     	lda var_ch_DPCM_Retrig			; Retrigger
001011r 2  F0 0D        	beq :+
001013r 2  CE rr rr     	dec var_ch_DPCM_RetrigCntr
001016r 2  D0 08        	bne :+
001018r 2  8D rr rr     	sta var_ch_DPCM_RetrigCntr
00101Br 2  A9 01        	lda #$01
00101Dr 2  8D rr rr     	sta var_ch_Note + DPCM_CHANNEL
001020r 2               :
001020r 2               
001020r 2  AD rr rr     	lda var_ch_DPCMDAC				; See if delta counter should be updated
001023r 2  30 03        	bmi @SkipDAC
001025r 2  8D 11 40     	sta $4011
001028r 2               @SkipDAC:
001028r 2  A9 80        	lda #$80						; Skip that later by storing a negative value
00102Ar 2  8D rr rr     	sta var_ch_DPCMDAC
00102Dr 2               
00102Dr 2  AD rr rr     	lda var_ch_Note + DPCM_CHANNEL
001030r 2  F0 42        	beq @KillDPCM
001032r 2  30 3A        	bmi @SkipDPCM
001034r 2  AD rr rr     	lda var_ch_DPCM_EffPitch
001037r 2  10 03        	bpl :+
001039r 2  AD rr rr     	lda var_ch_SamplePitch
00103Cr 2  8D 10 40     :	sta $4010
00103Fr 2  A9 80        	lda #$80
001041r 2  8D rr rr     	sta var_ch_DPCM_EffPitch
001044r 2               
001044r 2  18           	clc
001045r 2  AD rr rr     	lda var_ch_SamplePtr
001048r 2  6D rr rr     	adc var_ch_DPCM_Offset
00104Br 2  8D 12 40     	sta $4012
00104Er 2               
00104Er 2  AD rr rr     	lda var_ch_DPCM_Offset
001051r 2  0A           	asl a
001052r 2  0A           	asl a
001053r 2  85 rr        	sta var_Temp
001055r 2  38           	sec
001056r 2  AD rr rr     	lda var_ch_SampleLen
001059r 2  E5 rr        	sbc var_Temp
00105Br 2  8D 13 40     	sta $4013
00105Er 2  A9 80        	lda #$80
001060r 2  8D rr rr     	sta var_ch_Note + DPCM_CHANNEL
001063r 2  A9 0F        	lda #$0F
001065r 2  8D 15 40     	sta $4015
001068r 2  A9 1F        	lda #$1F
00106Ar 2  8D 15 40     	sta $4015
00106Dr 2  60           	rts
00106Er 2               @SkipDPCM:
00106Er 2  C9 FF            cmp #$FF
001070r 2  F0 01            beq @ReleaseDPCM
001072r 2  60           	rts
001073r 2               @ReleaseDPCM:
001073r 2               ; todo
001073r 2               ;	lda #$0F
001073r 2               ;	sta $4015
001073r 2               ;	lda #$80
001073r 2               ;	sta var_ch_Note + DPCM_CHANNEL
001073r 2  60           	rts
001074r 2               @KillDPCM:
001074r 2  A9 0F        	lda #$0F
001076r 2  8D 15 40     	sta $4015
001079r 2  A9 80        	lda #$80
00107Br 2  8D 11 40     	sta $4011
00107Er 2  8D rr rr     	sta var_ch_Note + DPCM_CHANNEL
001081r 2               .endif
001081r 2               @Return:
001081r 2  60           	rts
001082r 2               
001082r 2               ; Lookup tables
001082r 2               
001082r 2               ft_duty_table:
001082r 2  00 40 80 C0  	.byte $00, $40, $80, $C0
001086r 2               
001086r 2               ; Volume table: (column volume) * (instrument volume)
001086r 2               ft_volume_table:
001086r 2  00 00 00 00  	.byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
00108Ar 2  00 00 00 00  
00108Er 2  00 00 00 00  
001096r 2  00 01 01 01  	.byte 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
00109Ar 2  01 01 01 01  
00109Er 2  01 01 01 01  
0010A6r 2  00 01 01 01  	.byte 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2
0010AAr 2  01 01 01 01  
0010AEr 2  01 01 01 01  
0010B6r 2  00 01 01 01   	.byte 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3
0010BAr 2  01 01 01 01  
0010BEr 2  01 01 02 02  
0010C6r 2  00 01 01 01   	.byte 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4
0010CAr 2  01 01 01 01  
0010CEr 2  02 02 02 02  
0010D6r 2  00 01 01 01   	.byte 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5
0010DAr 2  01 01 02 02  
0010DEr 2  02 03 03 03  
0010E6r 2  00 01 01 01   	.byte 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6
0010EAr 2  01 02 02 02  
0010EEr 2  03 03 04 04  
0010F6r 2  00 01 01 01   	.byte 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7
0010FAr 2  01 02 02 03  
0010FEr 2  03 04 04 05  
001106r 2  00 01 01 01   	.byte 0, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8
00110Ar 2  02 02 03 03  
00110Er 2  04 04 05 05  
001116r 2  00 01 01 01   	.byte 0, 1, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9
00111Ar 2  02 03 03 04  
00111Er 2  04 05 06 06  
001126r 2  00 01 01 02   	.byte 0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10
00112Ar 2  02 03 04 04  
00112Er 2  05 06 06 07  
001136r 2  00 01 01 02   	.byte 0, 1, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 10, 11
00113Ar 2  02 03 04 05  
00113Er 2  05 06 07 08  
001146r 2  00 01 01 02   	.byte 0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 9, 10, 11, 12
00114Ar 2  03 04 04 05  
00114Er 2  06 07 08 08  
001156r 2  00 01 01 02   	.byte 0, 1, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13
00115Ar 2  03 04 05 06  
00115Er 2  06 07 08 09  
001166r 2  00 01 01 02   	.byte 0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14
00116Ar 2  03 04 05 06  
00116Er 2  07 08 09 0A  
001176r 2  00 01 02 03   	.byte 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
00117Ar 2  04 05 06 07  
00117Er 2  08 09 0A 0B  
001186r 2               
001186r 1               
001186r 1               .ifdef USE_VRC6
001186r 1               	.include "vrc6.s"
001186r 1               .endif
001186r 1               .ifdef USE_VRC7
001186r 1               	.include "vrc7.s"
001186r 1               .endif
001186r 1               .ifdef USE_MMC5
001186r 1               	.include "mmc5.s"
001186r 1               .endif
001186r 1               .ifdef USE_FDS
001186r 1               	.include "fds.s"
001186r 1               .endif
001186r 1               .ifdef USE_N106
001186r 1               	.include "n106.s"
001186r 1               .endif
001186r 1               
001186r 1               .ifdef PAL_PERIOD_TABLE
001186r 1               ft_notes_pal:							; Note periods for PAL (remove this if you don't need PAL support)
001186r 1  68 0C B6 0B  	.incbin "freq_pal.bin"
00118Ar 1  0E 0B 6F 0A  
00118Er 1  D9 09 4B 09  
001246r 1               .endif
001246r 1               
001246r 1               .ifdef NTSC_PERIOD_TABLE
001246r 1               ft_notes_ntsc:							; Note periods for NTSC (remove this if you don't need NTSC support)
001246r 1  5B 0D 9C 0C  	.incbin "freq_ntsc.bin"
00124Ar 1  E6 0B 3B 0B  
00124Er 1  9A 0A 01 0A  
001306r 1               .endif
001306r 1               
001306r 1               .ifdef USE_VRC6
001306r 1               ft_periods_sawtooth:
001306r 1               	.incbin "freq_sawtooth.bin"			; Note periods for VRC6 sawtooth
001306r 1               .endif
001306r 1               
001306r 1               .ifdef USE_FDS
001306r 1               ft_periods_fds:
001306r 1               	.incbin "freq_fds.bin"				; Note periods for FDS
001306r 1               .endif
001306r 1               
001306r 1               ; Vibrato table (256 bytes)
001306r 1               ft_vibrato_table:
001306r 1  00 00 00 00  	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
00130Ar 1  00 00 00 00  
00130Er 1  00 00 00 00  
001316r 1  00 00 00 00  	.byte $00, $00, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
00131Ar 1  00 00 01 01  
00131Er 1  01 01 01 01  
001326r 1  00 00 00 00  	.byte $00, $00, $00, $00, $01, $01, $01, $01, $02, $02, $02, $02, $02, $02, $02, $02
00132Ar 1  01 01 01 01  
00132Er 1  02 02 02 02  
001336r 1  00 00 00 01  	.byte $00, $00, $00, $01, $01, $01, $02, $02, $02, $03, $03, $03, $03, $03, $03, $03
00133Ar 1  01 01 02 02  
00133Er 1  02 03 03 03  
001346r 1  00 00 00 01  	.byte $00, $00, $00, $01, $01, $02, $02, $03, $03, $03, $04, $04, $04, $04, $04, $04
00134Ar 1  01 02 02 03  
00134Er 1  03 03 04 04  
001356r 1  00 00 01 02  	.byte $00, $00, $01, $02, $02, $03, $03, $04, $04, $05, $05, $06, $06, $06, $06, $06
00135Ar 1  02 03 03 04  
00135Er 1  04 05 05 06  
001366r 1  00 00 01 02  	.byte $00, $00, $01, $02, $03, $04, $05, $06, $07, $07, $08, $08, $09, $09, $09, $09
00136Ar 1  03 04 05 06  
00136Er 1  07 07 08 08  
001376r 1  00 01 02 03  	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08, $09, $09, $0A, $0B, $0B, $0B, $0B
00137Ar 1  04 05 06 07  
00137Er 1  08 09 09 0A  
001386r 1  00 01 02 04  	.byte $00, $01, $02, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0C, $0D, $0D, $0D
00138Ar 1  05 06 07 08  
00138Er 1  09 0A 0B 0C  
001396r 1  00 01 03 04  	.byte $00, $01, $03, $04, $06, $08, $09, $0A, $0C, $0D, $0E, $0E, $0F, $10, $10, $10
00139Ar 1  06 08 09 0A  
00139Er 1  0C 0D 0E 0E  
0013A6r 1  00 02 04 06  	.byte $00, $02, $04, $06, $08, $0A, $0C, $0D, $0F, $11, $12, $13, $14, $15, $15, $15
0013AAr 1  08 0A 0C 0D  
0013AEr 1  0F 11 12 13  
0013B6r 1  00 02 05 08  	.byte $00, $02, $05, $08, $0B, $0E, $10, $13, $15, $17, $18, $1A, $1B, $1C, $1D, $1D
0013BAr 1  0B 0E 10 13  
0013BEr 1  15 17 18 1A  
0013C6r 1  00 04 08 0C  	.byte $00, $04, $08, $0C, $10, $14, $18, $1B, $1F, $22, $24, $26, $28, $2A, $2B, $2B
0013CAr 1  10 14 18 1B  
0013CEr 1  1F 22 24 26  
0013D6r 1  00 06 0C 12  	.byte $00, $06, $0C, $12, $18, $1E, $23, $28, $2D, $31, $35, $38, $3B, $3D, $3E, $3F
0013DAr 1  18 1E 23 28  
0013DEr 1  2D 31 35 38  
0013E6r 1  00 09 12 1B  	.byte $00, $09, $12, $1B, $24, $2D, $35, $3C, $43, $4A, $4F, $54, $58, $5B, $5E, $5F
0013EAr 1  24 2D 35 3C  
0013EEr 1  43 4A 4F 54  
0013F6r 1  00 0C 18 25  	.byte $00, $0C, $18, $25, $30, $3C, $47, $51, $5A, $62, $6A, $70, $76, $7A, $7D, $7F
0013FAr 1  30 3C 47 51  
0013FEr 1  5A 62 6A 70  
001406r 1               
001406r 1               ;
001406r 1               ; An example of including music follows
001406r 1               ;
001406r 1               
001406r 1               .export ft_music_init
001406r 1               .export ft_music_play
001406r 1               .import ft_music_addr
001406r 1               
001406r 1               
